<?xml version="1.0" encoding="UTF-8" ?>
<class name="@GDScript" version="3.5" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../doc/class.xsd">
	<brief_description>
		Встроенные функции языка GDScript.
	</brief_description>
	<description>
		Список основных встроенных функций GDScript. Математические функции и другие утилиты. Все остальное предоставляется объектами. (Ключевые слова: встроенные, встроенные в, глобальные функции).
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="Color8">
			<return type="Color" />
			<argument index="0" name="r8" type="int" />
			<argument index="1" name="g8" type="int" />
			<argument index="2" name="b8" type="int" />
			<argument index="3" name="a8" type="int" default="255" />
			<description>
				Возвращает цвет, построенный из целочисленных красного, зеленого, синего и альфа-каналов. Каждый канал должен содержать 8 бит информации в диапазоне от 0 до 255.
				[code]r8[/code] красный канал
				[code]g8[/code] зеленый канал
				[code]b8[/code] синий канал
				[code]a8[/code] альфа-канал
				[codeblock]
				red = Color8(255, 0, 0)
				[/codeblock]
			</description>
		</method>
		<method name="ColorN">
			<return type="Color" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="alpha" type="float" default="1.0" />
			<description>
				Возвращает цвет в соответствии со стандартизированным [code]name[/code] с [code]alpha[/code] в диапазоне от 0 до 1.
				[codeblock]
				red = ColorN("red", 1)
				[/codeblock]
				Поддерживаемые имена цветов совпадают с константами, определенными в [Color].
			</description>
		</method>
		<method name="abs">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает абсолютное значение параметра [code]s[/code] (т.е. положительное значение).
				[codeblock]
				a = abs(-1) # a равно 1
				[/codeblock]
			</description>
		</method>
		<method name="acos">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает косинус дуги [code]s[/code] в радианах. Используется для получения угла косинуса [code]s[/code]. [code]s[/code] должен быть между [code]-1.0[/code] и [code]1.0[/code] (включительно), иначе [метод acos] вернет [константу NAN].
				[codeblock]
				# c - 0,523599 или 30 градусов, если преобразовать с помощью rad2deg(s).
				c = acos(0.866025)
				[/codeblock]
			</description>
		</method>
		<method name="asin">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает синус дуги [code]s[/code] в радианах. Используется для получения угла синуса [code]s[/code]. [code]s[/code] должен находиться между [code]-1.0[/code] и [code]1.0[/code] (включительно), иначе [метод asin] вернет [константу NAN].
				[codeblock]
				# s равно 0,523599 или 30 градусам, если преобразовать с помощью rad2deg(s).
				s = asin(0.5)
				[/codeblock]
			</description>
		</method>
		<method name="assert">
			<return type="void" />
			<argument index="0" name="condition" type="bool" />
			<argument index="1" name="message" type="String" default="&quot;&quot;" />
			<description>
				Утверждает, что [код]условие[/код] является [код]истинным[/код]. Если [code]условие[/code] является [code]ложным[/code], генерируется ошибка. При запуске из редактора запущенный проект также будет приостановлен до тех пор, пока вы его не возобновите. Это можно использовать как более сильную форму [method push_error] для сообщения об ошибках разработчикам проекта или пользователям дополнений.
				[b]Примечание:[/b] По соображениям производительности код внутри [method assert] выполняется только в отладочных сборках или при запуске проекта из редактора. Не включайте в вызов [method assert] код, имеющий побочные эффекты. В противном случае проект будет вести себя по-другому при экспорте в режиме релиза.
				Необязательный аргумент [code]message[/code], если он указан, отображается в дополнение к общему сообщению "Assertion failed". Вы можете использовать его для предоставления дополнительных сведений о том, почему утверждение не удалось.
				[codeblock]
				# Представьте, что мы хотим, чтобы скорость всегда находилась в диапазоне от 0 до 20.
				var speed = -10
				assert(speed &lt; 20) # Правда, программа будет продолжаться
				assert(speed &gt;= 0) # Ложь, программа будет остановлена
				assert(speed &gt;= 0 и скорость &lt; 20) # Вы также можете объединить два условных оператора в одну проверку
				assert(speed &lt; 20, "speed = %f, но ограничение скорости составляет 20" % скорости) # Показать сообщение с уточняющими деталями
				[/codeblock]
			</description>
		</method>
		<method name="atan">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает тангенс дуги [code]s[/code] в радианах. Используйте его для получения угла из тангенса угла в тригонометрии: [code]atan(tan(angle)) == angle[/code].
				Метод не может знать, в какой квадрант должен попадать угол. Смотрите [метод atan2], если у вас есть и [code]y[/code], и [code]x[/code].
				[codeblock]
				a = atan(0.5) # a составляет 0.463648
				[/codeblock]
			</description>
		</method>
		<method name="atan2">
			<return type="float" />
			<argument index="0" name="y" type="float" />
			<argument index="1" name="x" type="float" />
			<description>
				Возвращает тангенс дуги [code]y/x[/code] в радианах. Используется для получения угла наклона касательной [code]y/x[/code]. Для вычисления значения метод учитывает знак обоих аргументов, чтобы определить квадрант.
				Важное замечание: по условию, координата Y стоит на первом месте.
				[codeblock]
				a = atan2(0, -1) # a составляет 3.141593
				[/codeblock]
			</description>
		</method>
		<method name="bytes2var">
			<return type="Variant" />
			<argument index="0" name="bytes" type="PoolByteArray" />
			<argument index="1" name="allow_objects" type="bool" default="false" />
			<description>
				Декодирует байтовый массив обратно в значение. Если [code]allow_objects[/code] имеет значение [code]true[/code], декодирование объектов разрешено.
				[b]ВНИМАНИЕ:[/b] Десериализованный объект может содержать код, который будет выполнен. Не используйте эту опцию, если сериализованный объект получен из ненадежных источников, чтобы избежать потенциальных угроз безопасности (удаленное выполнение кода).
			</description>
		</method>
		<method name="cartesian2polar">
			<return type="Vector2" />
			<argument index="0" name="x" type="float" />
			<argument index="1" name="y" type="float" />
			<description>
				Преобразует 2D точку, выраженную в картезианской системе координат (оси X и Y), в полярную систему координат (расстояние от начала координат и угол).
			</description>
		</method>
		<method name="ceil">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Округляет [code]s[/code] по возрастанию (в сторону положительной бесконечности), возвращая наименьшее целое число, которое не меньше [code]s[/code].
				[codeblock]
				a = ceil(1.45)  # a является 2.0
				a = ceil(1.001) # a является 2.0
				[/codeblock]
				См. также [метод floor], [метод round], [метод stepify] и [int].
			</description>
		</method>
		<method name="char">
			<return type="String" />
			<argument index="0" name="code" type="int" />
			<description>
				Возвращает символ в виде строки с заданной точкой кода Unicode (совместимой с кодом ASCII).
				[codeblock]
				a = char(65)      # a является "A"
				a = char(65 + 32) # a является "a"
				a = char(8364)    # a является "€"
				[/codeblock]
				Это обратное действие по отношению к [method ord].
			</description>
		</method>
		<method name="clamp">
			<return type="float" />
			<argument index="0" name="value" type="float" />
			<argument index="1" name="min" type="float" />
			<argument index="2" name="max" type="float" />
			<description>
				Зажимает [code]value[/code] и возвращает значение не меньше [code]min[/code] и не больше [code]max[/code].
				[codeblock]
				a = clamp(1000, 1, 20) # a является 20
				a = clamp(-10, 1, 20)  # a является 1
				a = clamp(15, 1, 20)   # a является 15
				[/codeblock]
			</description>
		</method>
		<method name="convert">
			<return type="Variant" />
			<argument index="0" name="what" type="Variant" />
			<argument index="1" name="type" type="int" />
			<description>
				Преобразовывает тип в другой наилучшим образом. Параметр [code]type[/code] использует значения [enum Variant.Type].
				[codeblock]
				a = Vector2(1, 0)
				# Выводит 1
				print(a.length())
				a = convert(a, TYPE_STRING)
				# Выводит 6, так как "(1, 0)" - это 6 символов.
				print(a.length())
				[/codeblock]
			</description>
		</method>
		<method name="cos">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает косинус угла [code]s[/code] в радианах.
				[codeblock]
				a = cos(TAU) # a является 1.0
				a = cos(PI)  # a является -1.0
				[/codeblock]
			</description>
		</method>
		<method name="cosh">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает гиперболический косинус [code]s[/code] в радианах.
				[codeblock]
				print(cosh(1)) # Выводит 1.543081
				[/codeblock]
			</description>
		</method>
		<method name="db2linear">
			<return type="float" />
			<argument index="0" name="db" type="float" />
			<description>
				Преобразование децибел в линейную энергию (звук).
			</description>
		</method>
		<method name="decimals">
			<return type="int" />
			<argument index="0" name="step" type="float" />
			<description>
				Утративший силу псевдоним для [method step_decimals].
			</description>
		</method>
		<method name="dectime">
			<return type="float" />
			<argument index="0" name="value" type="float" />
			<argument index="1" name="amount" type="float" />
			<argument index="2" name="step" type="float" />
			<description>
				[b]Примечание:[/b] [code]dectime[/code] был устаревшим и будет удален в Godot 4.0, вместо него используйте [method move_toward].
				Возвращает результат уменьшения [code]значения[/code] на [code]шаг[/code] * [code]количество[/code].
				[codeblock]
				a = dectime(60, 10, 0.1)) # a является 59.0
				[/codeblock]
			</description>
		</method>
		<method name="deep_equal">
			<return type="bool" />
			<argument index="0" name="a" type="Variant" />
			<argument index="1" name="b" type="Variant" />
			<description>
				Сравнивает два значения, проверяя их фактическое содержимое, обращаясь к любому [Array] или [Dictionary] до самого глубокого уровня.
				Это сравнивается с [code]==[/code] несколькими способами:
				- Для [code]null[/code], [code]int[/code], [code]float[/code], [code]String[/code], [code]Object[/code] и [code]RID[/code] как [code]deep_equal[/code], так и [code]==[/code] работают одинаково.
				- Для [code]Dictionary[/code], [code]==[/code] считает равенство тогда и только тогда, когда обе переменные указывают на один и тот же [code]Dictionary[/code], без рекурсии или осведомленности о содержимом вообще.
				- Для [code]Array[/code], [code]==[/code] считает равенство тогда и только тогда, когда каждый элемент первого [code]Array[/code] равен своему аналогу во втором [code]Array[/code], как говорит сам [code]==[/code]. Из этого следует, что [code]==[/code] рекурсирует в [code]Array[/code], но не в [code]Dictionary[/code].
				Короче говоря, везде, где потенциально может быть задействован [code]Dictionary[/code], если вы хотите получить истинное сравнение с учетом содержимого, вы должны использовать [code]deep_equal[/code].
			</description>
		</method>
		<method name="deg2rad">
			<return type="float" />
			<argument index="0" name="deg" type="float" />
			<description>
				Преобразует угол, выраженный в градусах, в радианы.
				[codeblock]
				r = deg2rad(180) # r является 3.141593
				[/codeblock]
			</description>
		</method>
		<method name="dict2inst">
			<return type="Object" />
			<argument index="0" name="dict" type="Dictionary" />
			<description>
				Преобразует словарь (ранее созданный с помощью [method inst2dict]) обратно в экземпляр. Полезно для десериализации.
			</description>
		</method>
		<method name="ease">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<argument index="1" name="curve" type="float" />
			<description>
				Возвращает "смягченное" значение [code]x[/code] на основе функции смягчения, заданной с помощью [code]curve[/code]. Эта функция смягчения основана на экспоненте. Кривая [code]curve[/code] может быть любым числом с плавающей точкой, при этом определенные значения приводят к следующим вариантам поведения:
				[codeblock]
				- Ниже -1,0 (исключительно): Облегчение входа-выхода
				- 1.0: Линейный
				- От -1,0 до 0,0 (исключительно): Облегчение в
				- 0.0: Постоянный
				- От 0,0 до 1,0 (исключая): Облегчение
				- 1.0: Линейный
				- Больше 1,0 (исключительно): Облегчение
				[/codeblock]
				[url=https://raw.githubusercontent.com/godotengine/godot-docs/3.5/img/ease_cheatsheet.png]ease() curve values cheatsheet[/url]
				См. также [метод smoothstep]. Если вам нужно выполнить более сложные переходы, используйте [Tween] или [AnimationPlayer].
			</description>
		</method>
		<method name="exp">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Естественная экспоненциальная функция. Возводит математическую константу [b]e[/b] в степень [code]s[/code] и возвращает ее.
				Приблизительное значение [b]e[/b] равно 2,71828, и его можно получить с помощью [code]exp(1)[/code].
				Для получения экспоненты к другим основаниям используйте метод [method pow].
				[codeblock].
				a = exp(2) # Приблизительно 7.39
				[/codeblock]
			</description>
		</method>
		<method name="floor">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Округляет [code]s[/code] в сторону уменьшения (к отрицательной бесконечности), возвращая наибольшее целое число, которое не больше [code]s[/code].
				[codeblock]
				a = floor(2.45) # a равно 2.0
				a = floor(2.99) # a равно 2.0
				a = floor(-2.99) # a равно -3.0
				[/codeblock].
				Смотрите также [method ceil], [method round], [method stepify] и [int].
				[b]Примечание:[/b] Этот метод возвращает число float. Если вам нужно целое число и [code]s[/code] - неотрицательное число, вы можете использовать [code]int(s)[/code] напрямую.
			</description>
		</method>
		<method name="fmod">
			<return type="float" />
			<argument index="0" name="a" type="float" />
			<argument index="1" name="b" type="float" />
			<description>
				Возвращает остаток с плавающей точкой от [code]a/b[/code], сохраняя знак [code]a[/code].
				[codeblock]
				r = fmod(7, 5.5) # r равно 1.5
				[/codeblock]
				Для операции целочисленного остатка используйте оператор %.
			</description>
		</method>
		<method name="fposmod">
			<return type="float" />
			<argument index="0" name="a" type="float" />
			<argument index="1" name="b" type="float" />
			<description>
				Возвращает модуль [code]a/b[/code] с плавающей запятой, который одинаково оборачивается как в положительную, так и в отрицательную сторону.
				[codeblock]
				for i in 7:
				    var x = 0.5 * i - 1.5
				    print("%4.1f %4.1f %4.1f" % [x, fmod(x, 1.5), fposmod(x, 1.5)])
				[/codeblock].
				Выводит:
				[codeblock]
				-1.5 -0.0  0.0
				-1.0 -1.0  0.5
				-0.5 -0.5  1.0
				 0.0  0.0  0.0
				 0.5  0.5  0.5
				 1.0  1.0  1.0
				 1.5  0.0  0.0
				[/codeblock]
			</description>
		</method>
		<method name="funcref">
			<return type="FuncRef" />
			<argument index="0" name="instance" type="Object" />
			<argument index="1" name="funcname" type="String" />
			<description>
				Возвращает ссылку на указанную функцию [code]funcname[/code] в узле [code]instance[/code]. Поскольку в GDscript функции не являются объектами первого класса, используйте [code]funcref[/code], чтобы сохранить [FuncRef] в переменной и вызвать ее позже.
				[codeblock]
				func foo():
				    return("bar")

				a = funcref(self, "foo")
				print(a.call_func()) # Выведет текст "bar"
				[/codeblock]
			</description>
		</method>
		<method name="get_stack">
			<return type="Array" />
			<description>
				Возвращает массив словарей, представляющих текущий стек вызовов. См. также [метод print_stack].
				[codeblock]
				func _ready():
				    foo()

				func foo():
				    bar()

				func bar():
				    print(get_stack())
				[/codeblock]
				напечатает
				[codeblock]
				[{function:bar, line:12, source:res://script.gd}, {function:foo, line:9, source:res://script.gd}, {function:_ready, line:6, source:res://script.gd}]
				[/codeblock]
				[b]Примечание:[/b] [метод get_stack] работает только в том случае, если запущенный экземпляр подключен к отладочному серверу (т.е. к экземпляру редактора). [метод get_stack] не будет работать в проектах, экспортированных в режиме релиза, или в проектах, экспортированных в режиме отладки, если они не подключены к отладочному серверу.
			</description>
		</method>
		<method name="hash">
			<return type="int" />
			<argument index="0" name="var" type="Variant" />
			<description>
				Возвращает целочисленный хэш переданной переменной.
				[codeblock]
				print(hash("a")) # Выводит 177670
				[/codeblock]
			</description>
		</method>
		<method name="inst2dict">
			<return type="Dictionary" />
			<argument index="0" name="inst" type="Object" />
			<description>
				Возвращает переданный экземпляр, преобразованный в словарь (полезно для сериализации).
				[codeblock]
				var foo = "bar"
				func _ready():
				    var d = inst2dict(self)
				    print(d.keys())
				    print(d.values())
				[/codeblock]
				Выведет:
				[codeblock]
				[@subpath, @path, foo]
				[, res://test.gd, bar]
				[/codeblock]
			</description>
		</method>
		<method name="instance_from_id">
			<return type="Object" />
			<argument index="0" name="instance_id" type="int" />
			<description>
				Возвращает объект, соответствующий [code]instance_id[/code]. Все объекты имеют уникальный идентификатор(ID) экземпляра.
				[codeblock]
				var foo = "bar"
				func _ready():
				    var id = get_instance_id()
				    var inst = instance_from_id(id)
				    print(inst.foo) # Выведет bar
				[/codeblock]
			</description>
		</method>
		<method name="inverse_lerp">
			<return type="float" />
			<argument index="0" name="from" type="float" />
			<argument index="1" name="to" type="float" />
			<argument index="2" name="weight" type="float" />
			<description>
				Возвращает коэффициент интерполяции или экстраполяции, учитывающий диапазон, указанный в [code]from[/code] и [code]to[/code], и интерполируемое значение, указанное в [code]weight[/code]. Возвращаемое значение будет находиться между [code]0.0[/code] и [code]1.0[/code], если [code]weight[/code] находится между [code]from[/code] и [code]to[/code] (включительно). Если [code]weight[/code] находится вне этого диапазона, то будет возвращен коэффициент экстраполяции (возвращаемое значение меньше, чем [code]0.0[/code] или больше, чем [code]1.0[/code]). Если это нежелательно, используйте [method clamp] для результата [method inverse_lerp].
				[codeblock]
				# Коэффициент интерполяции в вызове `lerp()` ниже равен 0,75.
				var middle = lerp(20, 30, 0.75)
				# `среднее` теперь равно 27,5.
				# Теперь мы притворимся, что забыли исходное соотношение и хотим его вернуть.
				var ratio = inverse_lerp(20, 30, 27.5)
				# `ratio` теперь равно 0,75.
				[/codeblock].
				Смотрите также [метод lerp], который выполняет обратную операцию, и [метод range_lerp] для преобразования непрерывного ряда значений в другой.
			</description>
		</method>
		<method name="is_equal_approx">
			<return type="bool" />
			<argument index="0" name="a" type="float" />
			<argument index="1" name="b" type="float" />
			<description>
				Возвращает [code]true[/code], если [code]a[/code] и [code]b[/code] приблизительно равны друг другу.
				Здесь "приблизительно равны" означает, что [code]a[/code] и [code]b[/code] находятся в пределах небольшого внутреннего эпсилона друг от друга, который увеличивается с ростом величины чисел.
				Бесконечные значения одного и того же знака считаются равными.
			</description>
		</method>
		<method name="is_inf">
			<return type="bool" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает, является ли [code]s[/code] бесконечным значением (либо положительной бесконечностью, либо отрицательной бесконечностью).
			</description>
		</method>
		<method name="is_instance_valid">
			<return type="bool" />
			<argument index="0" name="instance" type="Object" />
			<description>
				Возвращает, является ли [code]instance[/code] действительным объектом (например, не был ли он удален из памяти).
			</description>
		</method>
		<method name="is_nan">
			<return type="bool" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает, является ли [code]s[/code] значением NaN ("Not a Number" - не числом или invalid - Недействительным).
			</description>
		</method>
		<method name="is_zero_approx">
			<return type="bool" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает [code]true[/code], если [code]s[/code] равно нулю или почти нулю.
				Этот метод быстрее, чем использование [method is_equal_approx] с одним значением в качестве нуля.
			</description>
		</method>
		<method name="len">
			<return type="int" />
			<argument index="0" name="var" type="Variant" />
			<description>
				Возвращает длину переменной [code]var[/code]. Длина - это количество символов в строке, количество элементов в массиве, размер словаря и т. д.
				[b]Примечание:[/b] Генерирует фатальную ошибку, если Variant не может предоставить длину.
				[codeblock]
				a = [1, 2, 3, 4]
				len(a) # вернет 4
				[/codeblock]
			</description>
		</method>
		<method name="lerp">
			<return type="Variant" />
			<argument index="0" name="from" type="Variant" />
			<argument index="1" name="to" type="Variant" />
			<argument index="2" name="weight" type="float" />
			<description>
				Линейно интерполирует между двумя значениями на коэффициент, заданный в [code]weight[/code]. Для выполнения интерполяции [code]weight[/code] должен находиться в диапазоне от [code]0.0[/code] до [code]1.0[/code] (включительно). Однако значения за пределами этого диапазона допустимы и могут быть использованы для [i]экстраполяции[/i]. Если это нежелательно, используйте [method clamp] для результата [method lerp].
				Если аргументы [code]from[/code] и [code]to[/code] имеют тип [int] или [float], то возвращаемое значение будет [float].
				Если оба аргумента имеют один и тот же тип вектора ([Vector2], [Vector3] или [Color]), то возвращаемое значение будет того же типа ([code]lerp[/code] затем вызывает метод [code]linear_interpolate[/code] типа вектора).
				[codeblock]
				lerp(0, 4, 0.75) # Возвращает 3.0
				lerp(Vector2(1, 5), Vector2(3, 2), 0.5) # Возвращает Vector2(2, 3.5)
				[/codeblock].
				Смотрите также [метод inverse_lerp], который выполняет обратную операцию. Чтобы выполнить облегченную интерполяцию с помощью [method lerp], объедините его с [method ease] или [method smoothstep]. См. также [метод range_lerp] для преобразования непрерывного ряда значений в другой.
			</description>
		</method>
		<method name="lerp_angle">
			<return type="float" />
			<argument index="0" name="from" type="float" />
			<argument index="1" name="to" type="float" />
			<argument index="2" name="weight" type="float" />
			<description>
				Линейно интерполирует два угла (в радианах) по нормализованному значению.
				Аналогично [method lerp], но интерполирует правильно, если углы огибают [константу @GDScript.TAU]. Чтобы выполнить облегченную интерполяцию с помощью [method lerp_angle], объедините его с [method ease] или [method smoothstep].
				[codeblock]
				extends Sprite
				var elapsed = 0.0
				func _process(delta):
				    var min_angle = deg2rad(0.0)
				    var max_angle = deg2rad(90.0)
				    rotation = lerp_angle(min_angle, max_angle, elapsed)
				    elapsed += delta
				[/codeblock]
				[b]Примечание:[/b] Этот метод использует кратчайший путь между [code]from[/code] и [code]to[/code]. Однако, когда эти два угла находятся на расстоянии примерно [code]PI + k * TAU[/code] для любого целого числа [code]k[/code], не очевидно, в какую сторону они отклоняются из-за ошибок точности вычислений с плавающей точкой. Например, [code]lerp_angle(0, PI, weight)[/code] вращается против часовой стрелки, а [code]lerp_angle(0, PI + 5 * TAU, weight)[/code] вращается по часовой стрелке.
			</description>
		</method>
		<method name="linear2db">
			<return type="float" />
			<argument index="0" name="nrg" type="float" />
			<description>
				Преобразует линейную энергию в децибелы (аудио). Это может быть использовано для реализации ползунков громкости, которые ведут себя так, как ожидается (поскольку громкость не линейна). Пример:
				[codeblock]
				# "Слайдер" относится к узлу, который наследует Range, например HSlider или VSlider.
				# Его диапазон должен быть сконфигурирован для перехода от 0 к 1.
				# Измените имя шины, если вы хотите изменить громкость только определенной шины.
				AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Master"), linear2db($Slider.value))
				[/codeblock]
			</description>
		</method>
		<method name="load">
			<return type="Resource" />
			<argument index="0" name="path" type="String" />
			<description>
				Загружает ресурс из файловой системы, расположенной по адресу [code]path[/code]. Ресурс загружается при вызове метода (если на него уже нет ссылки в другом месте, например, в другом скрипте или в сцене), что может вызвать небольшую задержку, особенно при загрузке сцен. Чтобы избежать ненужных задержек при многократной загрузке, либо храните ресурс в переменной, либо используйте [method preload].
				[b]Примечание:[/b] Пути к ресурсам можно получить, щелкнув правой кнопкой мыши на ресурсе в доке FileSystem и выбрав "Copy Path", или перетащив файл из дока FileSystem в сценарий.
				[codeblock]
				# Загрузите сцену с именем main, расположенную в корне каталога проекта, и кэшируйте ее в переменную.
				var main = load("res://main.tscn") # main будет содержать ресурс PackedScene.
				[/codeblock]
				[b]Важно:[/b] Путь должен быть абсолютным, локальный путь просто вернет [code]null[/code].
				Этот метод является упрощенной версией метода [method ResourceLoader.load], который может быть использован для более сложных сценариев.
			</description>
		</method>
		<method name="log">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает [url=https://en.wikipedia.org/wiki/Natural_logarithm]натуральный логарифм[/url] от [code]s[/code] (основание [url=https://en.wikipedia.org/wiki/E_(математическая_константа)][i]e[/i][/url], причем [i]e[/i] равно примерно 2,71828). Это количество времени, необходимое для достижения определенного уровня непрерывного роста.
				[b]Примечание:[/b] Это не то же самое, что функция "log" на большинстве калькуляторов, которая использует логарифм по основанию 10. Чтобы использовать логарифм по основанию 10, используйте [code]log(x) / log(10)[/code].
				[codeblock]
				log(10) # Возвращает 2.302585
				[/codeblock]
				[b]Примечание:[/b] Логарифм от [code]0[/code] возвращает [code]-inf[/code], а отрицательные значения возвращают [code]-nan[/code].
			</description>
		</method>
		<method name="max">
			<return type="float" />
			<argument index="0" name="a" type="float" />
			<argument index="1" name="b" type="float" />
			<description>
				Возвращает максимальное из двух значений.
				[codeblock]
				max(1, 2) # Возвращает 2
				max(-3.99, -4) # Возвращает -3.99
				[/codeblock]
			</description>
		</method>
		<method name="min">
			<return type="float" />
			<argument index="0" name="a" type="float" />
			<argument index="1" name="b" type="float" />
			<description>
				Возвращает минимальное из двух значений.
				[codeblock]
				min(1, 2) # Возвращает 1
				min(-3.99, -4) # Возвращает -4
				[/codeblock]
			</description>
		</method>
		<method name="move_toward">
			<return type="float" />
			<argument index="0" name="from" type="float" />
			<argument index="1" name="to" type="float" />
			<argument index="2" name="delta" type="float" />
			<description>
				Перемещает [code]from[/code] в сторону [code]to[/code] на величину [code]delta[/code].
				Для перемещения в сторону используйте отрицательное значение [code]delta[/code].
				[codeblock]
				move_toward(5, 10, 4) # Возвращает 9
				move_toward(10, 5, 4) # Возвращает 6
				move_toward(10, 5, -1.5) # Возвращает 11.5
				[/codeblock]
			</description>
		</method>
		<method name="nearest_po2">
			<return type="int" />
			<argument index="0" name="value" type="int" />
			<description>
				Возвращает ближайшую равную или большую степень 2 для целого числа [code]value[/code].
				Другими словами, возвращается наименьшее значение [code]a[/code], где [code]a = pow(2, n)[/code] такое, что [code]value &lt;= a[/code] для некоторого неотрицательного целого числа [code]n[/code].
				[codeblock].
				nearest_po2(3) # Возвращает 4
				nearest_po2(4) # Возвращает 4
				nearest_po2(5) # Возвращает 8

				nearest_po2(0) # Возвращает 0 (это может быть не то, что вы ожидаете)
				nearest_po2(-1) # Возвращает 0 (это может быть не то, что вы ожидаете)
				[/codeblock]
				[b]ВНИМАНИЕ:[/b] Из-за особенностей реализации эта функция возвращает [code]0[/code], а не [code]1[/code] для неположительных значений [code]value[/code] (в действительности 1 - это наименьшая целая степень 2).
			</description>
		</method>
		<method name="ord">
			<return type="int" />
			<argument index="0" name="char" type="String" />
			<description>
				Возвращает целое число, представляющее кодовую точку Unicode данного символа [code]char[/code].
				[codeblock]
				a = ord("A") # a равно 65
				a = ord("a") # a равно 97
				a = ord("€") # a равно 8364
				[/codeblock]
				Это обратный вариант [метода char].
			</description>
		</method>
		<method name="parse_json">
			<return type="Variant" />
			<argument index="0" name="json" type="String" />
			<description>
				Разберите текст JSON на варианты. (Используйте [метод typeof], чтобы проверить, является ли тип Variant тем, что вы ожидаете).
				[b]Примечание:[/b] В спецификации JSON не определены типы integer или float, а только тип [i]число[/i]. Поэтому при разборе текста JSON все числовые значения будут преобразованы к типу [float].
				[b]Примечание:[/b] Объекты JSON не сохраняют порядок ключей, как словари Godot, поэтому при построении словаря из JSON не следует полагаться на то, что ключи будут расположены в определенном порядке. Напротив, массивы JSON сохраняют порядок элементов:
				[codeblock]
				var p = JSON.parse('["hello", "world", "!"]')
				if typeof(p.result) == TYPE_ARRAY:
				    print(p.result[0]) # Выведет "hello"
				else:
				    push_error("Unexpected results.")
				[/codeblock]
				Смотрите также [JSON] для альтернативного способа разбора текста JSON.
			</description>
		</method>
		<method name="polar2cartesian">
			<return type="Vector2" />
			<argument index="0" name="r" type="float" />
			<argument index="1" name="th" type="float" />
			<description>
				Преобразует 2D точку, выраженную в полярной системе координат (расстояние от начала координат [code]r[/code] и угол [code]th[/code]), в декартовую систему координат (оси X и Y).
			</description>
		</method>
		<method name="posmod">
			<return type="int" />
			<argument index="0" name="a" type="int" />
			<argument index="1" name="b" type="int" />
			<description>
				Возвращает модуль целого числа [code]a/b[/code], которое одинаково обертывается в положительную и отрицательную сторону.
				[codeblock]
				for i in range(-3, 4):
				    print("%2d %2d %2d" % [i, i % 3, posmod(i, 3)])
				[/codeblock]
				Производит:
				[codeblock]
				-3  0  0
				-2 -2  1
				-1 -1  2
				 0  0  0
				 1  1  1
				 2  2  2
				 3  0  0
				[/codeblock]
			</description>
		</method>
		<method name="pow">
			<return type="float" />
			<argument index="0" name="base" type="float" />
			<argument index="1" name="exp" type="float" />
			<description>
				Возвращает результат [code]base[/code], возведенного в степень [code]exp[/code].
				[codeblock]
				pow(2, 5) # Возвращает 32.0
				[/codeblock]
			</description>
		</method>
		<method name="preload">
			<return type="Resource" />
			<argument index="0" name="path" type="String" />
			<description>
				Возвращает [Resource] из файловой системы, расположенной по адресу [code]path[/code]. Ресурс загружается во время разбора скрипта, то есть загружается вместе со скриптом, и [метод preload] фактически выступает в качестве ссылки на этот ресурс. Обратите внимание, что метод требует постоянного пути. Если вы хотите загрузить ресурс по динамическому/переменному пути, используйте [method load].
				[b]Примечание:[/b] Пути к ресурсам можно получить, щелкнув правой кнопкой мыши на ресурсе в панели активов и выбрав "Copy Path", или перетащив файл из дока FileSystem в скрипт.
				[codeblock]
				# Инстанс/Инициализация сцены.
				var diamond = preload("res://diamond.tscn").instance()
				[/codeblock]
			</description>
		</method>
		<method name="print" qualifiers="vararg">
			<return type="void" />
			<description>
				Преобразует один или несколько аргументов любого типа в строку наилучшим образом и выводит их на консоль.
				[codeblock]
				a = [1, 2, 3]
				print("a", "=", a) # Выводит a=[1, 2, 3]
				[/codeblock]
				[b]Примечание:[/b] Рассмотрите возможность использования [method push_error] и [method push_warning] для печати сообщений об ошибках и предупреждениях вместо [method print]. Это позволяет отличить их от сообщений печати, используемых для отладки, а также вывести трассировку стека при печати ошибки или предупреждения.
			</description>
		</method>
		<method name="print_debug" qualifiers="vararg">
			<return type="void" />
			<description>
				Подобно [method print], но включает текущий кадр стека при запуске с включенным отладчиком.
				Вывод в консоль будет выглядеть примерно так:
				[codeblock]
				Печать теста
				   At: res://test.gd:15:_process()
				[/codeblock]
			</description>
		</method>
		<method name="print_stack">
			<return type="void" />
			<description>
				Печатает трассировку стека в текущем месте кода. См. также [метод get_stack].
				Вывод в консоль будет выглядеть примерно так:
				[codeblock]
				Фрейм 0 - res://test.gd:16 в функции '_process'
				[/codeblock]
				[b]Примечание:[/b] [method print_stack] работает только в том случае, если запущенный экземпляр подключен к отладочному серверу (т.е. экземпляру редактора). [method print_stack] не будет работать в проектах, экспортированных в режиме релиза, или в проектах, экспортированных в режиме отладки, если они не подключены к отладочному серверу.
			</description>
		</method>
		<method name="printerr" qualifiers="vararg">
			<return type="void" />
			<description>
				Выводит один или несколько аргументов в виде строк наилучшим образом в стандартную строку ошибок.
				[codeblock]
				printerr("prints to stderr")
				[/codeblock]
			</description>
		</method>
		<method name="printraw" qualifiers="vararg">
			<return type="void" />
			<description>
				Выводит на консоль один или несколько аргументов в виде строк в наилучшем виде. Новая строка в конце не добавляется.
				[codeblock]
				printraw("A")
				printraw("B")
				# Печатает AB
				[/codeblock]
				[b]Примечание:[/b] Из-за ограничений встроенной консоли Godot, этот метод печатает только в терминал. Если вам нужно печатать в редакторе, используйте другой метод, например [method print].
			</description>
		</method>
		<method name="prints" qualifiers="vararg">
			<return type="void" />
			<description>
				Выводит один или несколько аргументов на консоль с пробелом между каждым аргументом.
				[codeblock]
				prints("A", "B", "C") # Печатает A B C
				[/codeblock]
			</description>
		</method>
		<method name="printt" qualifiers="vararg">
			<return type="void" />
			<description>
				Выводит один или несколько аргументов в консоль с табуляцией между каждым аргументом.
				[codeblock]
				printt("A", "B", "C") # Печатает A       B       C
				[/codeblock]
			</description>
		</method>
		<method name="push_error">
			<return type="void" />
			<argument index="0" name="message" type="String" />
			<description>
				Выводит сообщение об ошибке во встроенный отладчик Godot и в терминал ОС.
				[codeblock]
				push_error("test error") # Выводит "test error" в отладчик и терминал как вызов ошибки
				[/codeblock]
				[b]Примечание:[/b] Ошибки, выведенные таким образом, не приостанавливают выполнение проекта. Чтобы вывести сообщение об ошибке и приостановить выполнение проекта в отладочных сборках, используйте вместо этого [code]assert(false, "test error")[/code].
			</description>
		</method>
		<method name="push_warning">
			<return type="void" />
			<argument index="0" name="message" type="String" />
			<description>
				Выводит предупреждающее сообщение во встроенный отладчик Godot и в терминал ОС.
				[codeblock]
				push_warning("test warning") # Выводит "test warning" в отладчик и терминал как вызов предупреждения
				[/codeblock]
			</description>
		</method>
		<method name="rad2deg">
			<return type="float" />
			<argument index="0" name="rad" type="float" />
			<description>
				Преобразует угол, выраженный в радианах, в градусы.
				[codeblock]
				rad2deg(0.523599) # Возвращает 30.0
				[/codeblock]
			</description>
		</method>
		<method name="rand_range">
			<return type="float" />
			<argument index="0" name="from" type="float" />
			<argument index="1" name="to" type="float" />
			<description>
				Возвращает случайное значение с плавающей точкой между [code]from[/code] и [code]to[/code] (обе конечные точки включительно).
				[codeblock]
				prints(rand_range(0, 1), rand_range(0, 1)) # Выводит, например, 0.135591 0.405263
				[/codeblock]
				[b]Примечание:[/b] Это эквивалентно [code]randf() * (to - from) + from[/code].
			</description>
		</method>
		<method name="rand_seed">
			<return type="Array" />
			<argument index="0" name="seed" type="int" />
			<description>
				Random from seed(Случайный сид): передайте [code]seed[/code], и будет возвращен массив с числом и новым seed. Под "seed" здесь понимается внутреннее состояние генератора псевдослучайных чисел. Внутреннее состояние текущей реализации - 64 бита.
			</description>
		</method>
		<method name="randf">
			<return type="float" />
			<description>
				Возвращает случайное значение с плавающей точкой на интервале [code][0, 1][/code].
				[codeblock]
				randf() # Возвращает, например, 0.375671
				[/codeblock]
			</description>
		</method>
		<method name="randi">
			<return type="int" />
			<description>
				Возвращает случайное беззнаковое 32-битное целое число. Используйте остаток для получения случайного значения в интервале [code][0, N - 1][/code] (где N меньше 2^32).
				[codeblock]
				randi() # Возвращает случайное целое число в интервале от 0 до 2^32 - 1
				randi() % 20 # Возвращает случайное целое число от 0 до 19
				randi() % 100 # Возвращает случайное целое число от 0 до 99
				randi() % 100 + 1 # Возвращает случайное целое число от 1 до 100
				[/codeblock]
			</description>
		</method>
		<method name="randomize">
			<return type="void" />
			<description>
				Рандомизирует seed (или внутреннее состояние) генератора случайных чисел. В текущей реализации для повторного засева используется число, основанное на времени.
				[codeblock]
				func _ready():
				    randomize()
				[/codeblock]
			</description>
		</method>
		<method name="range" qualifiers="vararg">
			<return type="Array" />
			<description>
				Возвращает массив с заданным диапазоном. [метод range] может быть вызван тремя способами:
				[code]range(n: int)[/code]: Начинается с 0, увеличивается с шагом в 1 и останавливается [i]перед[/i] [code]n[/code]. Аргумент [code]n[/code] является [b]эксклюзивным[/b].
				[code]range(b: int, n: int)[/code]: Начинается с [code]b[/code], увеличивается с шагом в 1 и останавливается [i]перед[/i] [code]n[/code]. Аргументы [code]b[/code] и [code]n[/code] являются [b]инклюзивными[/b] и [b]эксклюзивными[/b], соответственно.
				[code]range(b: int, n: int, s: int)[/code]: Начинается с [code]b[/code], увеличивается/уменьшается на шаг [code]s[/code] и останавливается [i]перед[/i] [code]n[/code]. Аргументы [code]b[/code] и [code]n[/code] являются [b]инклюзивными[/b] и [b]эксклюзивными[/b], соответственно. Аргумент [code]s[/code] [b]может[/b] быть отрицательным, но не [code]0[/code]. Если [code]s[/code] равен [code]0[/code], выводится сообщение об ошибке.
				Метод [method range] преобразует все аргументы в [int] перед обработкой.
				[b]Примечание:[/b] Возвращает пустой массив, если ни одно значение не удовлетворяет ограничению на значение (например, [code]range(2, 5, -1)[/code] или [code]range(5, 5, 1)[/code]).
				Примеры:
				[codeblock]
				print(range(4))        # Выведет [0, 1, 2, 3]
				print(range(2, 5))     # Выведет [2, 3, 4]
				print(range(0, 6, 2))  # Выведет [0, 2, 4]
				print(range(4, 1, -1)) # Выведет [4, 3, 2]
				[/codeblock]
				Чтобы выполнить итерацию по [Array] назад, используйте:
				[codeblock]
				var array = [3, 6, 9]
				for i in range(array.size(), 0, -1):
				    print(array[i - 1])
				[/codeblock]
				Вывод:
				[codeblock]
				9
				6
				3
				[/codeblock]
			</description>
		</method>
		<method name="range_lerp">
			<return type="float" />
			<argument index="0" name="value" type="float" />
			<argument index="1" name="istart" type="float" />
			<argument index="2" name="istop" type="float" />
			<argument index="3" name="ostart" type="float" />
			<argument index="4" name="ostop" type="float" />
			<description>
				Сопоставляет [code]значение[/code] из диапазона [code][istart, istop][/code] в [code][ostart, ostop][/code]. См. также [method lerp] и [method inverse_lerp]. Если [code]value[/code] находится за пределами [code][istart, istop][/code], то результирующее значение также будет находиться за пределами [code][ostart, ostop][/code]. Если это нежелательно, используйте [method clamp] для результата [method range_lerp].
				[codeblock]
				range_lerp(75, 0, 100, -1, 1) # Возвращает 0,5
				[/codeblock]
				Для сложных случаев использования, когда вам нужно несколько диапазонов, используйте [Curve] или [Gradient].
			</description>
		</method>
		<method name="round">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Округляет [code]s[/code] до ближайшего целого числа, при этом половинные случаи округляются от нуля.
				[codeblock]
				a = round(2.49) # a равно 2.0
				a = round(2.5) # a равно 3.0
				a = round(2.51) # a равно 3.0
				[/codeblock].
				См. также [method floor], [method ceil], [method stepify] и [int].
			</description>
		</method>
		<method name="seed">
			<return type="void" />
			<argument index="0" name="seed" type="int" />
			<description>
				Задает seed для генератора случайных чисел.
				[codeblock]
				my_seed = "Godot Rocks"
				seed(my_seed.hash())
				[/codeblock]
			</description>
		</method>
		<method name="sign">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает знак [code]s[/code]: -1 или 1. Возвращает 0, если [code]s[/code] равен 0.
				[codeblock]
				sign(-6) # Возвращает -1
				sign(0) # Возвращает 0
				sign(6) # Возвращает 1
				[/codeblock]
			</description>
		</method>
		<method name="sin">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает синус угла [code]s[/code] в радианах.
				[codeblock]
				sin(0.523599) # Возвращает 0.5
				[/codeblock]
			</description>
		</method>
		<method name="sinh">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает гиперболический синус [code]s[/code].
				[codeblock]
				a = log(2.0) # Возвращает 0.693147
				sinh(a) # Возвращает 0.75
				[/codeblock]
			</description>
		</method>
		<method name="smoothstep">
			<return type="float" />
			<argument index="0" name="from" type="float" />
			<argument index="1" name="to" type="float" />
			<argument index="2" name="s" type="float" />
			<description>
				Возвращает результат гладкой интерполяции значения [code]s[/code] между [code]0[/code] и [code]1[/code] на основе того, где [code]s[/code] лежит по отношению к ребрам [code]from[/code] и [code]to[/code].
				Возвращаемое значение будет [code]0[/code], если [code]s &lt;= from[/code], и [code]1[/code], если [code]s &gt;= to[/code]. Если [code]s[/code] лежит между [code]from[/code] и [code]to[/code], возвращаемое значение следует S-образной кривой, которая отображает [code]s[/code] между [code]0[/code] и [code]1[/code].
				Эта S-образная кривая представляет собой кубический интерполятор Эрмита, заданный [code]f(y) = 3*y^2 - 2*y^3[/code], где [code]y = (x-from) / (to-from)[/code].
				[codeblock]
				smoothstep(0, 2, -5.0) # Возвращает 0.0
				smoothstep(0, 2, 0.5) # Возвращает 0.15625
				smoothstep(0, 2, 1.0) # Возвращает 0.5
				smoothstep(0, 2, 2.0) # Возвращает 1.0
				[/codeblock].
				По сравнению с [method ease] со значением кривой [code]-1.6521[/code], [method smoothstep] возвращает максимально гладкую кривую без резких изменений производной. Если вам нужно выполнить более сложные переходы, используйте [Tween] или [AnimationPlayer].
				[url=https://raw.githubusercontent.com/godotengine/godot-docs/3.5/img/smoothstep_ease_comparison.png]Сравнение возвращаемых значений smoothstep() и ease(x, -1.6521)[/url]
			</description>
		</method>
		<method name="sqrt">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает квадратный корень из [code]s[/code], где [code]s[/code] - неотрицательное число.
				[codeblock]
				sqrt(9) # Возвращает 3
				[/codeblock]
				[b]Примечание:[/b] Отрицательные значения [code]s[/code] возвращают NaN. Если вам нужны отрицательные значения, используйте [code]System.Numerics.Complex[/code] в C#.
			</description>
		</method>
		<method name="step_decimals">
			<return type="int" />
			<argument index="0" name="step" type="float" />
			<description>
				Возвращает позицию первой ненулевой цифры после десятичной точки. Обратите внимание, что максимальное возвращаемое значение равно 10, что является конструктивным решением в реализации.
				[codeblock]
				n = step_decimals(5) # n равно 0
				n = step_decimals(1.0005) # n равно 4
				n = step_decimals(0.000000005) # n равно 9
				[/codeblock]
			</description>
		</method>
		<method name="stepify">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<argument index="1" name="step" type="float" />
			<description>
				Привязывает плавающее значение [code]s[/code] к заданному [code]шагу[/code]. Это также можно использовать для округления числа с плавающей точкой до произвольного количества десятичных знаков.
				[codeblock]
				stepify(100, 32) # Возвращает 96,0
				stepify(3.14159, 0.01) # Возвращает 3.14
				[/codeblock]
				См. также [method ceil], [method floor], [method round] и [int].
			</description>
		</method>
		<method name="str" qualifiers="vararg">
			<return type="String" />
			<description>
				Преобразует один или несколько аргументов любого типа в строку наилучшим образом.
				[codeblock]
				var a = [10, 20, 30]
				var b = str(a);
				len(a) # Возвращает 3
				len(b) # Возвращает 12
				[/codeblock]
			</description>
		</method>
		<method name="str2var">
			<return type="Variant" />
			<argument index="0" name="string" type="String" />
			<description>
				Преобразует форматированную строку, возвращенную [методом var2str], в исходное значение.
				[codeblock]
				a = '{"a": 1, "b": 2 }'
				b = str2var(a)
				print(b["a"]) # Печатает 1
				[/codeblock]
			</description>
		</method>
		<method name="tan">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает тангенс угла [code]s[/code] в радианах.
				[codeblock]
				tan(deg2rad(45)) # Возвращает 1
				[/codeblock]
			</description>
		</method>
		<method name="tanh">
			<return type="float" />
			<argument index="0" name="s" type="float" />
			<description>
				Возвращает гиперболический тангенс [code]s[/code].
				[codeblock]
				a = log(2.0) # a равно 0.693147
				b = tanh(a) # b равно 0.6
				[/codeblock]
			</description>
		</method>
		<method name="to_json">
			<return type="String" />
			<argument index="0" name="var" type="Variant" />
			<description>
				Преобразует [Variant] [code]var[/code] в текст JSON и возвращает результат. Пригодится для сериализации данных для хранения или отправки по сети.
				[codeblock]
				# Оба числа ниже - целые числа.
				a = { "a": 1, "b": 2 }
				b = to_json(a)
				print(b) # {"a":1, "b":2}
				# Оба числа выше являются плавающими, даже если они отображаются без десятичных знаков.
				[/codeblock]
				[b]Примечание:[/b] В спецификации JSON не определены типы integer или float, а только тип [i]number[/i]. Поэтому при преобразовании [Variant] в текст JSON все числовые значения будут преобразованы в типы [float].
				Альтернативный способ преобразования [Variant] в текст JSON см. также в [JSON].
			</description>
		</method>
		<method name="type_exists">
			<return type="bool" />
			<argument index="0" name="type" type="String" />
			<description>
				Возвращает, существует ли данный класс в [ClassDB].
				[codeblock]
				type_exists("Sprite") # Возвращает true
				type_exists("Variant") # Возвращает false
				[/codeblock]
			</description>
		</method>
		<method name="typeof">
			<return type="int" />
			<argument index="0" name="what" type="Variant" />
			<description>
				Возвращает внутренний тип данного объекта Variant, используя значения [enum Variant.Type].
				[codeblock]
				p = parse_json('["a", "b", "c"]')
				if typeof(p) == TYPE_ARRAY:
				    print(p[0]) # Выводит a
				else:
				    print("unexpected results") # неожиданные результаты
				[/codeblock]
			</description>
		</method>
		<method name="validate_json">
			<return type="String" />
			<argument index="0" name="json" type="String" />
			<description>
				Проверяет, является ли [code]json[/code] корректными данными JSON. Возвращает пустую строку, если она верна, или сообщение об ошибке в противном случае.
				[codeblock]
				j = to_json([1, 2, 3])
				v = validate_json(j)
				if not v:
				    print("Valid JSON.") # верный JSON
				else:
				    push_error("Invalid JSON: " + v) # неверный JSON
				[/codeblock]
			</description>
		</method>
		<method name="var2bytes">
			<return type="PoolByteArray" />
			<argument index="0" name="var" type="Variant" />
			<argument index="1" name="full_objects" type="bool" default="false" />
			<description>
				Кодирует значение переменной в байтовый массив. Когда [code]full_objects[/code] имеет значение [code]true[/code], кодирование объектов разрешено (и потенциально может включать код).
			</description>
		</method>
		<method name="var2str">
			<return type="String" />
			<argument index="0" name="var" type="Variant" />
			<description>
				Преобразует переменную [code]var[/code] в форматированную строку, которую впоследствии можно разобрать с помощью [метода str2var].
				[codeblock]
				a = { "a": 1, "b": 2 }
				print(var2str(a))
				[/codeblock]
				Печатает
				[codeblock]
				{
				"a": 1,
				"b": 2
				}
				[/codeblock]
			</description>
		</method>
		<method name="weakref">
			<return type="WeakRef" />
			<argument index="0" name="obj" type="Object" />
			<description>
				Возвращает слабую ссылку на объект.
				Слабой ссылки на объект недостаточно, чтобы сохранить объект живым: когда единственными оставшимися ссылками на объект являются слабые ссылки, сборщик мусора может уничтожить объект и использовать его память для чего-то другого. Однако до тех пор, пока объект не будет уничтожен, слабая ссылка может возвращать объект, даже если на него нет сильных ссылок.
			</description>
		</method>
		<method name="wrapf">
			<return type="float" />
			<argument index="0" name="value" type="float" />
			<argument index="1" name="min" type="float" />
			<argument index="2" name="max" type="float" />
			<description>
				Обертывает плавающее [code]значение[/code] между [code]min[/code] и [code]max[/code].
				Используется для создания поведения, похожего на цикл, или бесконечных поверхностей.
				[codeblock]
				# Бесконечный цикл между 5,0 и 9,9
				value = wrapf(value + 0.1, 5.0, 10.0)
				[/codeblock]
				[codeblock]
				# Бесконечное вращение (в радианах)
				angle = wrapf(angle + 0.1, 0.0, TAU)
				[/codeblock]
				[codeblock]
				# Бесконечное вращение (в радианах)
				angle = wrapf(angle + 0.1, -PI, PI)
				[/codeblock]
				[b]Примечание:[/b] Если [code]min[/code] равен [code]0[/code], это эквивалентно [method fposmod], так что лучше использовать его вместо этого.
				[code]wrapf[/code] является более гибким, чем подход [method fposmod], поскольку дает пользователю контроль над минимальным значением.
			</description>
		</method>
		<method name="wrapi">
			<return type="int" />
			<argument index="0" name="value" type="int" />
			<argument index="1" name="min" type="int" />
			<argument index="2" name="max" type="int" />
			<description>
				Обертывает целочисленное [code]значение[/code] между [code]min[/code] и [code]max[/code].
				Используется для создания поведения, похожего на цикл, или бесконечных поверхностей.
				[codeblock]
				# Бесконечный цикл между 5 и 9
				frame = wrapi(frame + 1, 5, 10)
				[/codeblock]
				[codeblock]
				# результат равен -2
				var result = wrapi(-6, -5, -1)
				[/codeblock]
				[b]Примечание:[/b] Если [code]min[/code] равен [code]0[/code], это эквивалентно [method posmod], так что лучше использовать его вместо этого.
				[code]wrapi[/code] является более гибким, чем подход [method posmod], предоставляя пользователю контроль над минимальным значением.
			</description>
		</method>
		<method name="yield">
			<return type="GDScriptFunctionState" />
			<argument index="0" name="object" type="Object" default="null" />
			<argument index="1" name="signal" type="String" default="&quot;&quot;" />
			<description>
				Останавливает выполнение функции и возвращает текущее приостановленное состояние вызывающей функции.
				Вызывающая функция должна вызвать [метод GDScriptFunctionState.resume] для состояния, чтобы возобновить выполнение. Это аннулирует состояние. Внутри возобновленной функции [code]yield()[/code] возвращает то, что было передано в вызов функции [code]resume()[/code].
				Если передать объект и сигнал, то выполнение будет возобновлено, когда объект издаст заданный сигнал. В этом случае [code]yield()[/code] возвращает аргумент, переданный в [code]emit_signal()[/code], если сигнал принимает только один аргумент, или массив, содержащий все аргументы, переданные в [code]emit_signal()[/code], если сигнал принимает несколько аргументов.
				Вы также можете использовать [code]yield[/code], чтобы дождаться завершения функции:
				[codeblock]
				func _ready():
				    yield(countdown(), "completed") # ожидание завершения функции countdown()
				    print('Ready')

				func countdown():
				    yield(get_tree(), "idle_frame") # возвращает объект GDScriptFunctionState для _ready().
				    print(3)
				    yield(get_tree().create_timer(1.0), "timeout")
				    print(2)
				    yield(get_tree().create_timer(1.0), "timeout")
				    print(1)
				    yield(get_tree().create_timer(1.0), "timeout")

				# Вывод:
				# 3
				# 2
				# 1
				# Ready
				[/codeblock]
				При уступке функции сигнал [code]completed[/code] будет выдан автоматически, когда функция вернется. Поэтому его можно использовать в качестве параметра [code]signal[/code] метода [code]yield[/code] для возобновления работы.
				Для того чтобы выполнить выход из функции, результирующая функция также должна вернуть [code]GDScriptFunctionState[/code]. Обратите внимание на [code]yield(get_tree(), "idle_frame")[/code] из приведенного выше примера.
			</description>
		</method>
	</methods>
	<constants>
		<constant name="PI" value="3.141593">
			Константа, которая показывает, сколько раз диаметр круга помещается по его периметру. Это эквивалентно [code]TAU / 2[/code].
		</constant>
		<constant name="TAU" value="6.283185">
			Константа окружности, окружность единичного круга в радианах. Это эквивалентно [code]PI * 2[/code], или 360 градусов во вращении.
		</constant>
		<constant name="INF" value="inf">
			Положительная бесконечность с плавающей запятой. Это результат деления с плавающей точкой, когда делитель равен [code]0.0[/code]. Для отрицательной бесконечности используйте [code]-INF[/code]. Деление на [code]-0.0[/code] приведет к отрицательной бесконечности, если числитель положительный, поэтому деление на [code]0.0[/code] - это не то же самое, что деление на [code]-0.0[/code] (несмотря на то, что [code]0.0 == -0.0[/code] возвращает [code]true[/code]).
			[b]Примечание:[/b] Числовая бесконечность является понятием только для чисел с плавающей точкой и не имеет эквивалента для целых чисел. Деление целого числа на [code]0[/code] не приведет к [constant INF] и вместо этого приведет к ошибке времени выполнения.
		</constant>
		<constant name="NAN" value="nan">
			Not a Numbe - "Не число", недопустимое значение с плавающей точкой. [константа NAN] обладает особыми свойствами, в том числе тем, что она не равна самой себе ([code]NAN == NAN[/code] возвращает [code]false[/code]). Она выводится некоторыми недопустимыми операциями, например делением [code]0.0[/code] с плавающей точкой на [code]0.0[/code].
			[b]Примечание:[/b] "Не число" - это понятие только для чисел с плавающей точкой и не имеет эквивалента для целых чисел. Деление целого числа [code]0[/code] на [code]0[/code] не приведет к [constant NAN] и вместо этого приведет к ошибке времени выполнения.
		</constant>
	</constants>
</class>
