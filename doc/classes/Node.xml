<?xml version="1.0" encoding="UTF-8" ?>
<class name="Node" inherits="Object" version="3.5" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../class.xsd">
	<brief_description>
		Базовый класс для всех объектов [i]сцены[/i].
	</brief_description>
	<description>
		Узлы - это строительные блоки Godot. Они могут быть назначены дочерними по отношению к другим узлам, в результате чего образуется дерево. Данный узел может содержать любое количество узлов в качестве дочерних, с условием, что все братья и сестры (прямые дети узла) должны иметь уникальные имена.
		Дерево узлов называется [i]сценой[/i]. Сцены могут быть сохранены на диске и затем инстанцированы в другие сцены. Это позволяет добиться очень высокой гибкости в архитектуре и модели данных проектов Godot.
		[b]Дерево сцены:[/b] Дерево [SceneTree] содержит активное дерево узлов. Когда узел добавляется в дерево сцены, он получает уведомление [constant NOTIFICATION_ENTER_TREE] и запускается его обратный вызов [method _enter_tree]. Дочерние узлы всегда добавляются [i]после[/i] родительского узла, то есть обратный вызов [method _enter_tree] родительского узла сработает раньше, чем у его дочернего узла.
		Как только все узлы добавлены в дерево сцены, они получают уведомление [constant NOTIFICATION_READY] и запускаются соответствующие обратные вызовы [method _ready]. Для групп узлов обратный вызов [method _ready] вызывается в обратном порядке, начиная с дочерних узлов и переходя к родительским узлам.
		Это означает, что при добавлении узла в дерево сцены для обратных вызовов будет использоваться следующий порядок: [метод _enter_tree] родителя, [метод _enter_tree] дочерних узлов, [метод _ready] дочерних узлов и, наконец, [метод _ready] родителя (рекурсивно для всего дерева сцены).
		[b]Обработка:[/b] Узлы могут переопределить состояние "обрабатывать", чтобы на каждом кадре получать обратный вызов с запросом на обработку (выполнение какого-либо действия). Обычная обработка (обратный вызов [method _process], переключается с помощью [method set_process]) происходит как можно быстрее и зависит от частоты кадров, поэтому в качестве аргумента передается время обработки [i]дельта[/i] (в секундах). Обработка физики (обратный вызов [method _physics_process], переключается с помощью [method set_physics_process]) происходит фиксированное количество раз в секунду (60 по умолчанию) и полезна для кода, связанного с физическим движком.
		Узлы также могут обрабатывать входные события. Когда они присутствуют, функция [method _input] будет вызываться для каждого входного сигнала, который получает программа. Во многих случаях это может быть излишним (если только не используется в простых проектах), и лучше использовать функцию [method _unhandled_input]; она вызывается, когда входное событие не было обработано никем другим (обычно узлами GUI [Control]), гарантируя, что узел получает только те события, которые предназначены для него.
		Чтобы отслеживать иерархию сцен (особенно при инстанцировании сцен в другие сцены), для узла можно задать "владельца" с помощью свойства [member owner]. Это позволит отслеживать, кто и что инстанцировал. В основном это полезно при написании редакторов и инструментов.
		Наконец, когда узел освобождается с помощью [method Object.free] или [method queue_free], он также освобождает все свои дочерние элементы.
		[b]Группы:[/b] Узлы могут быть добавлены во столько групп, сколько вы хотите, чтобы ими было легко управлять, вы можете создать такие группы, как "враги" или "коллекционные предметы", например, в зависимости от вашей игры. Смотрите [метод add_to_group], [метод is_in_group] и [метод remove_from_group]. Затем вы можете получить все узлы в этих группах, итерировать их и даже вызывать методы на группах через методы на [SceneTree].
		[b]Работа по сети с узлами:[/b] После подключения к серверу (или его создания, см. [NetworkedMultiplayerENet]) можно использовать встроенную систему RPC (удаленный вызов процедур) для взаимодействия по сети. Если вызвать [method rpc] с именем метода, он будет вызван локально и во всех подключенных пирах (пиры = клиенты и сервер, принимающий соединения). Чтобы определить, какой узел получил вызов RPC, Godot будет использовать свой [NodePath] (убедитесь, что имена узлов одинаковы для всех пиров). Также посмотрите учебник по сетевым технологиям высокого уровня и соответствующие демонстрации.
	</description>
	<tutorials>
		<link title="Nodes and Scenes">$DOCS_URL/getting_started/step_by_step/nodes_and_scenes.html</link>
		<link title="All Demos">https://github.com/godotengine/godot-demo-projects/</link>
	</tutorials>
	<methods>
		<method name="_enter_tree" qualifiers="virtual">
			<return type="void" />
			<description>
				Вызывается, когда узел попадает в [SceneTree] (например, при инстансировании, смене сцены или после вызова [method add_child] в скрипте). Если у узла есть дочерние элементы, то сначала будет вызван его обратный вызов [метода _enter_tree], а затем - дочерних элементов.
				Соответствует уведомлению [constant NOTIFICATION_ENTER_TREE] в [method Object._notification].
			</description>
		</method>
		<method name="_exit_tree" qualifiers="virtual">
			<return type="void" />
			<description>
				Вызывается, когда узел собирается покинуть [SceneTree] (например, при освобождении, смене сцены или после вызова [method remove_child] в скрипте). Если у узла есть дети, его обратный вызов [method _exit_tree] будет вызван последним, после того как все его дети покинут дерево.
				Соответствует уведомлению [constant NOTIFICATION_EXIT_TREE] в [method Object._notification] и сигналу [signal tree_exiting]. Чтобы получить уведомление, когда узел уже покинул активное дерево, подключитесь к сигналу [signal tree_exited].
			</description>
		</method>
		<method name="_get_configuration_warning" qualifiers="virtual">
			<return type="String" />
			<description>
				Строка, возвращаемая этим методом, отображается в качестве предупреждения в Scene Dock, если сценарий, который ее переопределяет, является [code]tool[/code] скриптом.
				Возвращение пустой строки не приводит к появлению предупреждения.
				Вызовите [метод update_configuration_warning], когда необходимо обновить предупреждение для этого узла.
			</description>
		</method>
		<method name="_input" qualifiers="virtual">
			<return type="void" />
			<argument index="0" name="event" type="InputEvent" />
			<description>
				Вызывается при возникновении события ввода. Событие ввода распространяется вверх по дереву узлов до тех пор, пока какой-либо узел его не потребит.
				Вызывается только в том случае, если включена обработка входных данных, что происходит автоматически, если этот метод переопределен, и может быть переключено с помощью [метода set_process_input].
				Чтобы поглотить событие ввода и остановить его дальнейшее распространение по другим узлам, можно вызвать [метод SceneTree.set_input_as_handled].
				Для игрового ввода обычно лучше подходят [method _unhandled_input] и [method _unhandled_key_input], поскольку они позволяют графическому интерфейсу перехватывать события первым.
				[b]Примечание:[/b] Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т.е. если он не является сиротой).
			</description>
		</method>
		<method name="_physics_process" qualifiers="virtual">
			<return type="void" />
			<argument index="0" name="delta" type="float" />
			<description>
				Вызывается на этапе обработки физики в главном цикле. Обработка физики означает, что частота кадров синхронизируется с физикой, т.е. переменная [code]delta[/code] должна быть постоянной. [code]delta[/code] указывается в секундах.
				Вызывается только если включена обработка физики, что происходит автоматически, если этот метод переопределен, и может быть переключено с помощью [method set_physics_process].
				Соответствует уведомлению [constant NOTIFICATION_PHYSICS_PROCESS] в [method Object._notification].
				[b]Примечание:[/b] Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т.е. если он не является сиротой).
			</description>
		</method>
		<method name="_process" qualifiers="virtual">
			<return type="void" />
			<argument index="0" name="delta" type="float" />
			<description>
				Вызывается на этапе обработки в главном цикле. Обработка происходит в каждом кадре и как можно быстрее, поэтому [code]дельта[/code] времени с предыдущего кадра не является постоянной. [code]delta[/code] указывается в секундах.
				Вызывается только при включенной обработке, которая происходит автоматически, если этот метод переопределен, и может быть переключена с помощью [method set_process].
				Соответствует уведомлению [constant NOTIFICATION_PROCESS] в [method Object._notification].
				[b]Примечание:[/b] Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т.е. если он не является сиротой).
			</description>
		</method>
		<method name="_ready" qualifiers="virtual">
			<return type="void" />
			<description>
				Вызывается, когда узел "готов/ready", т. е. когда и узел, и его дочерние элементы вошли в дерево сцены. Если у узла есть дочерние узлы, то сначала срабатывают их обратные вызовы [метода _ready], а затем родительский узел получает уведомление о готовности.
				Соответствует [константе NOTIFICATION_READY] уведомления в [методе Object._notification]. См. также ключевое слово [code]onready[/code] для переменных.
				Обычно используется для инициализации. Для еще более ранней инициализации можно использовать [метод Object._init]. См. также [метод _enter_tree].
				[b]Примечание:[/b] [метод _ready] может быть вызван только один раз для каждого узла. После удаления узла из дерева сцены и добавления его снова, [code]_ready[/code] не будет вызван второй раз. Это можно обойти, запросив повторный вызов с помощью [метода request_ready], который может быть вызван в любом месте перед повторным добавлением узла.
			</description>
		</method>
		<method name="_unhandled_input" qualifiers="virtual">
			<return type="void" />
			<argument index="0" name="event" type="InputEvent" />
			<description>
				Вызывается, когда событие [InputEvent] не было поглощено [методом _input] или каким-либо элементом [Control] графического интерфейса. Событие ввода распространяется вверх по дереву узлов до тех пор, пока какой-либо узел не поглотит его.
				Оно вызывается только в том случае, если включена обработка необработанного ввода, что происходит автоматически, если этот метод переопределен, и может быть переключено с помощью [метода set_process_unhandled_input].
				Чтобы поглотить событие ввода и остановить его дальнейшее распространение на другие узлы, можно вызвать [метод SceneTree.set_input_as_handled].
				Для ввода геймплея этот метод и [method _unhandled_key_input] обычно подходят лучше, чем [method _input], так как позволяют графическому интерфейсу перехватывать события первым.
				[b]Примечание:[/b] Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т.е. если он не является сиротой).
			</description>
		</method>
		<method name="_unhandled_key_input" qualifiers="virtual">
			<return type="void" />
			<argument index="0" name="event" type="InputEventKey" />
			<description>
				Вызывается, если событие [InputEventKey] не было использовано [методом _input] или каким-либо элементом [Control] графического интерфейса. Событие ввода распространяется вверх по дереву узлов до тех пор, пока какой-либо узел не поглотит его.
				Оно вызывается только в том случае, если включена обработка ввода по необработанным клавишам, что происходит автоматически, если этот метод переопределен, и может быть переключено с помощью [метода set_process_unhandled_key_input].
				Чтобы поглотить событие ввода и остановить его дальнейшее распространение по другим узлам, можно вызвать [метод SceneTree.set_input_as_handled].
				Для ввода геймплея этот метод и [method _unhandled_input] обычно подходят лучше, чем [method _input], поскольку они позволяют графическому интерфейсу перехватывать события первым.
				[b]Примечание:[/b] Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т.е. если он не является сиротой).
			</description>
		</method>
		<method name="add_child">
			<return type="void" />
			<argument index="0" name="node" type="Node" />
			<argument index="1" name="legible_unique_name" type="bool" default="false" />
			<description>
				Добавляет дочерний узел. Узлы могут иметь любое количество дочерних узлов, но каждый дочерний узел должен иметь уникальное имя. Дочерние узлы автоматически удаляются при удалении родительского узла, поэтому вся сцена может быть удалена удалением самого верхнего узла.
				Если [code]legible_unique_name[/code] имеет значение [code]true[/code], дочерний узел будет иметь человекочитаемое имя, основанное на имени инстансируемого узла, а не на его типе.
				[b]Примечание:[/b] Если у дочернего узла уже есть родитель, функция не сработает. Сначала используйте [метод remove_child] для удаления узла из его текущего родителя. Например:
				[codeblock]
				if child_node.get_parent():
				    child_node.get_parent().remove_child(child_node)
				add_child(child_node)
				[/codeblock]
				[b]Примечание:[/b] Если вы хотите, чтобы ребенок сохранялся в [PackedScene], вы должны установить [member owner] в дополнение к вызову [method add_child]. Обычно это актуально для [url=$DOCS_URL/tutorials/plugins/running_code_in_the_editor.html]инструментальных скриптов[/url] и [url=$DOCS_URL/tutorials/plugins/editor/index.html]плагинов редактора[/url]. Если вызвать [метод add_child] без установки [member owner], то добавленный узел [Node] не будет виден в дереве сцены, но будет виден в 2D/3D-виде.
			</description>
		</method>
		<method name="add_child_below_node">
			<return type="void" />
			<argument index="0" name="node" type="Node" />
			<argument index="1" name="child_node" type="Node" />
			<argument index="2" name="legible_unique_name" type="bool" default="false" />
			<description>
				Добавляет [code]child_node[/code] в качестве дочернего узла. Потомок помещается ниже данного [code]узла[/code] в списке дочерних узлов.
				Если [code]legible_unique_name[/code] имеет значение [code]true[/code], дочерний узел будет иметь человекочитаемое имя, основанное на имени инстанцируемого узла, а не на его типе.
			</description>
		</method>
		<method name="add_to_group">
			<return type="void" />
			<argument index="0" name="group" type="String" />
			<argument index="1" name="persistent" type="bool" default="false" />
			<description>
				Добавляет узел в группу. Группы - это помощники для наименования и организации подмножества узлов, например "враги" или "коллекционные предметы". Узел может находиться в любом количестве групп. Узлам можно присвоить группу в любой момент, но они не будут добавлены, пока не окажутся внутри дерева сцены (см. [метод is_inside_tree]). См. примечания в описании, а также методы групп в [SceneTree].
				Опция [code]persistent[/code] используется при упаковке узла в [PackedScene] и сохранении в файл. Непостоянные группы не сохраняются.
				[b]Примечание:[/b] По соображениям производительности порядок групп узлов [i]не гарантируется[/i]. Не следует полагаться на порядок групп узлов, так как он может меняться при разных запусках проекта.
			</description>
		</method>
		<method name="can_process" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если узел может обрабатываться, пока дерево сцены приостановлено (см. [member pause_mode]). Всегда возвращает [code]true[/code], если дерево сцены не приостановлено, и [code]false[/code], если узел не находится в дереве.
			</description>
		</method>
		<method name="create_tween">
			<return type="SceneTreeTween" />
			<description>
				Создает новый [SceneTreeTween] и привязывает его к этому узлу. Это эквивалентно действию:
				[codeblock]
				get_tree().create_tween().bind_node(self)
				[/codeblock]
			</description>
		</method>
		<method name="duplicate" qualifiers="const">
			<return type="Node" />
			<argument index="0" name="flags" type="int" default="15" />
			<description>
				Дублирует узел, возвращая новый узел.
				Вы можете настроить поведение с помощью [code]флагов[/code] (см. [enum DuplicateFlags]).
				[b]Примечание:[/b] Не будет работать, если узел содержит скрипт с аргументами конструктора (т.е. должен передать аргументы методу [method Object._init]). В этом случае узел будет продублирован без скрипта.
			</description>
		</method>
		<method name="find_node" qualifiers="const">
			<return type="Node" />
			<argument index="0" name="mask" type="String" />
			<argument index="1" name="recursive" type="bool" default="true" />
			<argument index="2" name="owned" type="bool" default="true" />
			<description>
				Находит потомка этого узла, имя которого соответствует [code]mask[/code], как в [методе String.match] (т.е. с учетом регистра, но [code]"*"[/code] соответствует нулю или более символов, а [code]"?"[/code] соответствует любому одиночному символу, кроме [code]"".""[/code]). Возвращает [code]null[/code], если не найдено ни одного подходящего [узла].
				[b]Примечание:[/b] Не ищет по полному пути, только по именам отдельных узлов.
				Если [code]owned[/code] имеет значение [code]true[/code], этот метод находит только те узлы, владельцем которых является данный узел. Это особенно важно для сцен, созданных через сценарий, поскольку у таких сцен нет владельца.
				[b]Примечание:[/b] Поскольку этот метод проходит по всем потомкам узла, это самый медленный способ получить ссылку на другой узел. По возможности лучше использовать вместо него [method get_node]. Чтобы не использовать [метод find_node] слишком часто, подумайте о кэшировании ссылки на узел в переменную.
			</description>
		</method>
		<method name="find_parent" qualifiers="const">
			<return type="Node" />
			<argument index="0" name="mask" type="String" />
			<description>
				Находит первого родителя текущего узла, имя которого соответствует [code]mask[/code], как в [методе String.match] (т.е. чувствительно к регистру, но [code]"*"[/code] соответствует нулю или более символов, а [code]"?"[/code] соответствует любому одиночному символу, кроме [code]"."[/code]).
				[b]Примечание:[/b] Он не сопоставляет полный путь, а только имена отдельных узлов.
				[b]Примечание:[/b] Поскольку этот метод идет вверх по дереву сцены, он может быть медленным в больших, глубоко вложенных деревьях сцен. По возможности используйте вместо него [метод get_node]. Чтобы не использовать [метод find_parent] слишком часто, подумайте о кэшировании ссылки на узел в переменную.
			</description>
		</method>
		<method name="get_child" qualifiers="const">
			<return type="Node" />
			<argument index="0" name="idx" type="int" />
			<description>
				Возвращает дочерний узел по его индексу (см. [метод get_child_count]). Этот метод часто используется для итерации всех дочерних узлов.
				Чтобы получить доступ к дочернему узлу по его имени, используйте [метод get_node].
			</description>
		</method>
		<method name="get_child_count" qualifiers="const">
			<return type="int" />
			<description>
				Возвращает количество дочерних узлов.
			</description>
		</method>
		<method name="get_children" qualifiers="const">
			<return type="Array" />
			<description>
				Возвращает массив ссылок на дочерние узлы узла.
			</description>
		</method>
		<method name="get_groups" qualifiers="const">
			<return type="Array" />
			<description>
				Возвращает массив со списком групп, в которые входит данный узел.
				[b]Примечание:[/b] По соображениям производительности порядок групп узлов [i]не гарантируется[/i]. Не следует полагаться на порядок групп узлов, поскольку он может меняться в разных проектах.
				[b]Примечание:[/b] Движок использует некоторые внутренние имена групп (все они начинаются с символа подчеркивания). Чтобы избежать конфликтов с внутренними группами, не добавляйте пользовательские группы, название которых начинается с символа подчеркивания. Чтобы исключить внутренние группы при переборе [метод get_groups], используйте следующий фрагмент:
				[codeblock]
				# Хранит только не внутренние группы узла (как массив строк).
				var non_internal_groups = []
				for group in get_groups():
				    if not group.begins_with("_"):
				        non_internal_groups.push_back(group)
				[/codeblock]
			</description>
		</method>
		<method name="get_index" qualifiers="const">
			<return type="int" />
			<description>
				Возвращает индекс узла, то есть его положение среди братьев и сестер его родителя.
			</description>
		</method>
		<method name="get_network_master" qualifiers="const">
			<return type="int" />
			<description>
				Возвращает идентификатор/ID пира мастера сети для этого узла. См. раздел [метод set_network_master].
			</description>
		</method>
		<method name="get_node" qualifiers="const">
			<return type="Node" />
			<argument index="0" name="path" type="NodePath" />
			<description>
				Извлекает узел. В качестве [NodePath] может быть указан относительный путь (от текущего узла) или абсолютный путь (в дереве сцены) к узлу. Если путь не существует, возвращается [code]null[/code] и записывается ошибка. Попытки получить доступ к методам на возвращаемом значении приведут к ошибке "Попытка вызова &lt;метода&gt; на нулевом экземпляре." ошибка.
				[b]Примечание:[/b] Получение абсолютных путей работает только в том случае, если узел находится внутри дерева сцены (см. [method is_inside_tree]).
				[b]Пример:[/b] Предположим, что ваш текущий узел - Character, а дерево следующее:
				[codeblock]
				/root
				/root/Character
				/root/Character/Sword
				/root/Character/Backpack/Dagger
				/root/MyGame
				/root/Swamp/Alligator
				/root/Swamp/Mosquito
				/root/Swamp/Goblin
				[/codeblock]
				Возможные пути:
				[codeblock]
				get_node("Sword")
				get_node("Backpack/Dagger")
				get_node("../Swamp/Alligator")
				get_node("/root/MyGame")
				[/codeblock]
			</description>
		</method>
		<method name="get_node_and_resource">
			<return type="Array" />
			<argument index="0" name="path" type="NodePath" />
			<description>
				Получает узел и один из его ресурсов, указанный в подимени [NodePath] (например, [code]Area2D/CollisionShape2D:shape[/code]). Если в [NodePath] указано несколько вложенных ресурсов, будет извлечен последний из них.
				Возвращаемое значение представляет собой массив размером 3: первый индекс указывает на [Node] (или [code]null[/code], если он не найден), второй индекс указывает на [Resource] (или [code]null[/code], если он не найден), а третий индекс - это оставшиеся [NodePath], если они есть.
				Например, если предположить, что [code]Area2D/CollisionShape2D[/code] является действительным узлом и что его свойству [code]shape[/code] присвоен ресурс [RectangleShape2D], то можно получить такой вывод:
				[codeblock]
				print(get_node_and_resource("Area2D/CollisionShape2D")) # [[CollisionShape2D:1161], Null, ]
				print(get_node_and_resource("Area2D/CollisionShape2D:shape")) # [[CollisionShape2D:1161], [RectangleShape2D:1156], ]
				print(get_node_and_resource("Area2D/CollisionShape2D:shape:extents")) # [[CollisionShape2D:1161], [RectangleShape2D:1156], :extents]
				[/codeblock]
			</description>
		</method>
		<method name="get_node_or_null" qualifiers="const">
			<return type="Node" />
			<argument index="0" name="path" type="NodePath" />
			<description>
				Аналогичен [method get_node], но не регистрирует ошибку, если [code]path[/code] не указывает на действительный [Node].
			</description>
		</method>
		<method name="get_parent" qualifiers="const">
			<return type="Node" />
			<description>
				Возвращает родительский узел текущего узла или [code]null[/code], если у узла нет родителя.
			</description>
		</method>
		<method name="get_path" qualifiers="const">
			<return type="NodePath" />
			<description>
				Возвращает абсолютный путь к текущему узлу. Это работает только в том случае, если текущий узел находится внутри дерева сцены (см. [метод is_inside_tree]).
			</description>
		</method>
		<method name="get_path_to" qualifiers="const">
			<return type="NodePath" />
			<argument index="0" name="node" type="Node" />
			<description>
				Возвращает относительный [NodePath] от этого узла к указанному [code]узлу/node[/code]. Оба узла должны находиться в одной сцене, иначе функция не сработает.
			</description>
		</method>
		<method name="get_physics_process_delta_time" qualifiers="const">
			<return type="float" />
			<description>
				Возвращает время, прошедшее (в секундах) с момента последнего кадра, связанного с физикой (см. [метод _physics_process]). Это всегда постоянное значение при обработке физики, если только количество кадров в секунду не изменяется с помощью [member Engine.iterations_per_second].
			</description>
		</method>
		<method name="get_position_in_parent" qualifiers="const">
			<return type="int" />
			<description>
				Возвращает порядок узла в ветви дерева сцены. Например, при вызове на первом дочернем узле позиция будет [code]0[/code].
			</description>
		</method>
		<method name="get_process_delta_time" qualifiers="const">
			<return type="float" />
			<description>
				Возвращает время, прошедшее (в секундах) с момента последнего обратного вызова процесса. Это значение может меняться от кадра к кадру.
			</description>
		</method>
		<method name="get_scene_instance_load_placeholder" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если это экземпляр load placeholder. См. раздел [InstancePlaceholder].
			</description>
		</method>
		<method name="get_tree" qualifiers="const">
			<return type="SceneTree" />
			<description>
				Возвращает дерево [SceneTree], содержащее этот узел.
			</description>
		</method>
		<method name="get_viewport" qualifiers="const">
			<return type="Viewport" />
			<description>
				Возвращает [Viewport] узла.
			</description>
		</method>
		<method name="has_node" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="path" type="NodePath" />
			<description>
				Возвращает [code]true[/code], если узел, на который указывает [NodePath], существует.
			</description>
		</method>
		<method name="has_node_and_resource" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="path" type="NodePath" />
			<description>
				Возвращает [code]true[/code], если [NodePath] указывает на действительный узел и его подимя указывает на действительный ресурс, например [code]Area2D/CollisionShape2D:shape[/code]. Свойства с типом, отличным от [Resource] (например, узлы или примитивные математические типы), не считаются ресурсами.
			</description>
		</method>
		<method name="is_a_parent_of" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="node" type="Node" />
			<description>
				Возвращает [code]true[/code], если данный узел является прямым или косвенным дочерним узлом текущего узла.
			</description>
		</method>
		<method name="is_displayed_folded" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если узел сложен (свернут) в доке сцены.
			</description>
		</method>
		<method name="is_greater_than" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="node" type="Node" />
			<description>
				Возвращает [code]true[/code], если данный узел находится позже в иерархии сцены, чем текущий узел.
			</description>
		</method>
		<method name="is_in_group" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="group" type="String" />
			<description>
				Возвращает [code]true[/code], если этот узел находится в указанной группе. См. примечания в описании, а также методы групп в [SceneTree].
			</description>
		</method>
		<method name="is_inside_tree" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если этот узел находится внутри [SceneTree].
			</description>
		</method>
		<method name="is_network_master" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если локальная система является хозяином этого узла.
			</description>
		</method>
		<method name="is_node_ready" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если узел готов, т.е. находится в дереве сцены и все его дочерние элементы инициализированы.
				[Метод request_ready] возвращает значение [code]false[/code].
			</description>
		</method>
		<method name="is_physics_interpolated" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если для этого узла установлен флаг интерполяции физики (см. [member physics_interpolation_mode]).
				[b]Примечание:[/b] Интерполяция будет активна, только если флаг установлен [b]и[/b] физическая интерполяция включена в [SceneTree]. Это можно проверить с помощью [метода is_physics_interpolated_and_enabled].
			</description>
		</method>
		<method name="is_physics_interpolated_and_enabled" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если интерполяция физики включена (см. [member physics_interpolation_mode]) [b]и[/b] включена в [SceneTree].
				Это удобная версия [method is_physics_interpolated], которая также проверяет, включена ли физическая интерполяция глобально.
				См. [member SceneTree.physics_interpolation] и [member ProjectSettings.physics/common/physics_interpolation].
			</description>
		</method>
		<method name="is_physics_processing" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если обработка физики включена (см. [метод set_physics_process]).
			</description>
		</method>
		<method name="is_physics_processing_internal" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если включена внутренняя обработка физики (см. [метод set_physics_process_internal]).
			</description>
		</method>
		<method name="is_processing" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если обработка включена (см. [метод set_process]).
			</description>
		</method>
		<method name="is_processing_input" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если узел обрабатывает входные данные (см. [метод set_process_input]).
			</description>
		</method>
		<method name="is_processing_internal" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если включена внутренняя обработка (см. [метод set_process_internal]).
			</description>
		</method>
		<method name="is_processing_unhandled_input" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если узел обрабатывает необработанный ввод (см. [метод set_process_unhandled_input]).
			</description>
		</method>
		<method name="is_processing_unhandled_key_input" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если узел обрабатывает необработанный ключевой ввод (см. [метод set_process_unhandled_key_input]).
			</description>
		</method>
		<method name="move_child">
			<return type="void" />
			<argument index="0" name="child_node" type="Node" />
			<argument index="1" name="to_position" type="int" />
			<description>
				Перемещает дочерний узел на другую позицию (порядок) среди других дочерних узлов. Поскольку вызовы, сигналы и т. д. выполняются по порядку дерева, изменение порядка дочерних узлов может быть полезным.
			</description>
		</method>
		<method name="print_stray_nodes">
			<return type="void" />
			<description>
				Выводит все блуждающие узлы (узлы за пределами [SceneTree]). Используется для отладки. Работает только в отладочных сборках.
			</description>
		</method>
		<method name="print_tree">
			<return type="void" />
			<description>
				Выводит дерево в stdout. Используется в основном для отладки. Эта версия отображает путь относительно текущего узла и подходит для копирования/вставки в функцию [method get_node].
				[b]Пример вывода:[/b]
				[codeblock]
				TheGame
				TheGame/Menu
				TheGame/Menu/Label
				TheGame/Menu/Camera2D
				TheGame/SplashScreen
				TheGame/SplashScreen/Camera2D
				[/codeblock]
			</description>
		</method>
		<method name="print_tree_pretty">
			<return type="void" />
			<description>
				Аналогично [method print_tree], печатает дерево в stdout. Эта версия выводит более графическое представление, похожее на то, что отображается в инспекторе сцен. Это полезно для осмотра больших деревьев.
				[b]Пример вывода:[/b]
				[codeblock]
				 ┖╴TheGame
				    ┠╴Menu
				    ┃  ┠╴Label
				    ┃  ┖╴Camera2D
				    ┖╴SplashScreen
				       ┖╴Camera2D
				[/codeblock]
			</description>
		</method>
		<method name="propagate_call">
			<return type="void" />
			<argument index="0" name="method" type="String" />
			<argument index="1" name="args" type="Array" default="[  ]" />
			<argument index="2" name="parent_first" type="bool" default="false" />
			<description>
				Вызывает заданный метод (если он присутствует) с аргументами, указанными в [code]args[/code], на данном узле и рекурсивно на всех его дочерних узлах. Если аргумент [code]parent_first[/code] равен [code]true[/code], то метод будет вызван сначала на текущем узле, а затем на всех его дочерних узлах. Если [code]parent_first[/code] равен [code]false[/code], то сначала будут вызваны дочерние узлы.
			</description>
		</method>
		<method name="propagate_notification">
			<return type="void" />
			<argument index="0" name="what" type="int" />
			<description>
				Рекурсивно уведомляет текущий узел и все его дочерние узлы, вызывая [метод Object.notification] на всех них.
			</description>
		</method>
		<method name="queue_free">
			<return type="void" />
			<description>
				Ставит узел в очередь на удаление в конце текущего кадра. При удалении все его дочерние узлы также будут удалены. Этот метод обеспечивает безопасное удаление узла, в отличие от [method Object.free]. Используйте [метод Object.is_queued_for_deletion], чтобы проверить, будет ли узел удален в конце кадра.
				[b]Важно:[/b] Если у вас есть переменная, указывающая на узел, она [i]не[/i] будет присвоена [code]null[/code] после освобождения узла. Вместо этого она будет указывать на [i]ранее освобожденный экземпляр[/i], и вы должны подтвердить ее с помощью [метода @GDScript.is_instance_valid], прежде чем пытаться вызвать ее методы или получить доступ к ее свойствам.
			</description>
		</method>
		<method name="raise">
			<return type="void" />
			<description>
				Перемещает этот узел в самый низ иерархии дочерних узлов родительского узла. Это часто бывает полезно в графических интерфейсах (узлы [Control]), поскольку порядок их отрисовки зависит от их порядка в дереве. Сначала рисуется верхний узел, затем все братья и сестры, расположенные ниже верхнего узла в иерархии, последовательно рисуются поверх него. После использования [code]raise[/code] элемент управления будет нарисован поверх своих братьев и сестер.
			</description>
		</method>
		<method name="remove_and_skip">
			<return type="void" />
			<description>
				Удаляет узел и устанавливает все его дочерние узлы в качестве дочерних узлов родительского узла (если он существует). Все подписки на события, проходящие мимо удаленного узла, будут отменены.
			</description>
		</method>
		<method name="remove_child">
			<return type="void" />
			<argument index="0" name="node" type="Node" />
			<description>
				Удаляет дочерний узел. Узел НЕ удаляется и должен быть удален вручную.
				[b]Примечание:[/b] Эта функция может установить [владельца-члена] удаленного узла (или его потомков) в [code]null[/code], если этот [владелец-член/owner] больше не является родителем или предком.
			</description>
		</method>
		<method name="remove_from_group">
			<return type="void" />
			<argument index="0" name="group" type="String" />
			<description>
				Удаляет узел из группы. См. примечания в описании, а также методы группы в [SceneTree].
			</description>
		</method>
		<method name="replace_by">
			<return type="void" />
			<argument index="0" name="node" type="Node" />
			<argument index="1" name="keep_data" type="bool" default="false" />
			<description>
				Заменяет узел в сцене на указанный. Подписки, проходящие через этот узел, будут потеряны.
				[b]Примечание:[/b] Данный узел станет новым родителем всех дочерних узлов, которые были у замененного узла.
				[b]Примечание:[/b] Замененный узел не освобождается автоматически, поэтому вам нужно либо сохранить его в переменной для последующего использования, либо освободить его с помощью [метода Object.free].
			</description>
		</method>
		<method name="request_ready">
			<return type="void" />
			<description>
				Запрашивает повторный вызов [code]_ready[/code]. Обратите внимание, что метод не будет вызван немедленно, а будет запланирован на тот момент, когда узел снова будет добавлен в дерево сцены (см. [метод _ready]). [code]_ready[/code] вызывается только для узла, который его запросил, что означает, что вам нужно запросить ready для каждого дочернего узла, если вы хотите, чтобы они тоже вызывали [code]_ready[/code] (в этом случае [code]_ready[/code] будет вызываться в том же порядке, что и обычно).
			</description>
		</method>
		<method name="reset_physics_interpolation">
			<return type="void" />
			<description>
				Когда интерполяция физики активна, перемещение узла на радикально другое преобразование (например, размещение в пределах уровня) может привести к заметному глюку, когда объект рендерится, перемещаясь из старой позиции в новую за время тика физики.
				Этот глюк можно предотвратить, вызвав [code]reset_physics_interpolation[/code], который временно отключает интерполяцию до завершения физического тика.
				[constant NOTIFICATION_RESET_PHYSICS_INTERPOLATION] будет получено узлом и всеми дочерними узлами рекурсивно.
				[b]Примечание:[/b] Эту функцию следует вызывать [b]после[/b] перемещения узла, а не до.
			</description>
		</method>
		<method name="rpc" qualifiers="vararg">
			<return type="Variant" />
			<argument index="0" name="method" type="String" />
			<description>
				Отправляет запрос на вызов удаленной процедуры для заданного [code]метода[/code] узлам в сети (и локально), по желанию отправляя все дополнительные аргументы в качестве аргументов метода, вызываемого RPC. Запрос на вызов будет получен только узлами с одинаковым [NodePath], включая точно такое же имя узла. Поведение зависит от конфигурации RPC для данного метода, см. [method rpc_config]. По умолчанию методы не открыты для RPC. См. также [method rset] и [method rset_config] для свойств. Возвращает [code]null[/code].
				[b]Примечание:[/b] Безопасно использовать RPC на клиентах можно только после того, как вы получили сигнал [code]connected_to_server[/code] от [SceneTree]. Вам также необходимо отслеживать состояние соединения, либо по сигналам [SceneTree], таким как [code]server_disconnected[/code], либо проверяя [code]SceneTree.network_peer.get_connection_status() == CONNECTION_CONNECTED[/code].
			</description>
		</method>
		<method name="rpc_config">
			<return type="void" />
			<argument index="0" name="method" type="String" />
			<argument index="1" name="mode" type="int" enum="MultiplayerAPI.RPCMode" />
			<description>
				Изменяет режим RPC для данного [code]метода[/code] на данный [code]режим[/code]. См. раздел [enum MultiplayerAPI.RPCMode]. Альтернативой является аннотирование методов и свойств соответствующими ключевыми словами ([code]remote[/code], [code]master[/code], [code]puppet[/code], [code]remotesync[/code], [code]masterync[/code], [code]puppetsync[/code]). По умолчанию методы не подвергаются сетевому взаимодействию (и RPC). Смотрите также свойства [method rset] и [method rset_config].
			</description>
		</method>
		<method name="rpc_id" qualifiers="vararg">
			<return type="Variant" />
			<argument index="0" name="peer_id" type="int" />
			<argument index="1" name="method" type="String" />
			<description>
				Отправляет [метод rpc] определенному пиру, идентифицированному по [code]peer_id[/code] (см. [method NetworkedMultiplayerPeer.set_target_peer]). Возвращает [code]null[/code].
			</description>
		</method>
		<method name="rpc_unreliable" qualifiers="vararg">
			<return type="Variant" />
			<argument index="0" name="method" type="String" />
			<description>
				Отправляет сообщение [method rpc] по ненадежному протоколу. Возвращает [code]null[/code].
			</description>
		</method>
		<method name="rpc_unreliable_id" qualifiers="vararg">
			<return type="Variant" />
			<argument index="0" name="peer_id" type="int" />
			<argument index="1" name="method" type="String" />
			<description>
				Отправляет сообщение [method rpc] определенному пиру, идентифицированному [code]peer_id[/code], используя ненадежный протокол (см. [method NetworkedMultiplayerPeer.set_target_peer]). Возвращает [code]null[/code].
			</description>
		</method>
		<method name="rset">
			<return type="void" />
			<argument index="0" name="property" type="String" />
			<argument index="1" name="value" type="Variant" />
			<description>
				Удаленно изменяет значение свойства на других пирах (и локально). Поведение зависит от конфигурации RPC для данного свойства, смотрите [method rset_config]. См. также [method rpc] для RPC для методов, большая часть информации применима и к этому методу.
			</description>
		</method>
		<method name="rset_config">
			<return type="void" />
			<argument index="0" name="property" type="String" />
			<argument index="1" name="mode" type="int" enum="MultiplayerAPI.RPCMode" />
			<description>
				Изменяет режим RPC для данного [code]свойства[/code] на данный [code]режим[/code]. См. раздел [enum MultiplayerAPI.RPCMode]. Альтернативой является аннотирование методов и свойств соответствующими ключевыми словами ([code]remote[/code], [code]master[/code], [code]puppet[/code], [code]remotesync[/code], [code]masterync[/code], [code]puppetsync[/code]). По умолчанию свойства не подвергаются сетевому взаимодействию (и RPC). О методах см. также [method rpc] и [method rpc_config].
			</description>
		</method>
		<method name="rset_id">
			<return type="void" />
			<argument index="0" name="peer_id" type="int" />
			<argument index="1" name="property" type="String" />
			<argument index="2" name="value" type="Variant" />
			<description>
				Удаленно изменяет значение свойства на определенном пире, идентифицированном по [code]peer_id[/code] (см. [метод NetworkedMultiplayerPeer.set_target_peer]).
			</description>
		</method>
		<method name="rset_unreliable">
			<return type="void" />
			<argument index="0" name="property" type="String" />
			<argument index="1" name="value" type="Variant" />
			<description>
				Удаленно изменяет значение свойства на других пирах (и локально) по ненадежному протоколу.
			</description>
		</method>
		<method name="rset_unreliable_id">
			<return type="void" />
			<argument index="0" name="peer_id" type="int" />
			<argument index="1" name="property" type="String" />
			<argument index="2" name="value" type="Variant" />
			<description>
				Удаленно изменяет значение свойства на определенном пире, идентифицированном по [code]peer_id[/code], используя ненадежный протокол (см. [метод NetworkedMultiplayerPeer.set_target_peer]).
			</description>
		</method>
		<method name="set_display_folded">
			<return type="void" />
			<argument index="0" name="fold" type="bool" />
			<description>
				Устанавливает свернутое состояние узла в доке сцены.
			</description>
		</method>
		<method name="set_network_master">
			<return type="void" />
			<argument index="0" name="id" type="int" />
			<argument index="1" name="recursive" type="bool" default="true" />
			<description>
				Устанавливает сетевым мастером узла пир с заданным идентификатором пира. Сетевой мастер - это пир, который имеет власть над узлом в сети. Используется в сочетании с ключевыми словами [code]master[/code] и [code]puppet[/code]. По умолчанию наследуется от родительского узла, который, в конечном счете, по умолчанию имеет идентификатор peer ID 1 (сервер). Если [code]recursive[/code], то данный пир рекурсивно устанавливается в качестве ведущего для всех дочерних узлов этого узла.
			</description>
		</method>
		<method name="set_physics_process">
			<return type="void" />
			<argument index="0" name="enable" type="bool" />
			<description>
				Включает или выключает обработку физики (т.е. фиксированной частоты кадров). Когда узел обрабатывается, он будет получать [constant NOTIFICATION_PHYSICS_PROCESS] с фиксированным (обычно 60 FPS, см. [member Engine.iterations_per_second] для изменения) интервалом (и обратный вызов [method _physics_process] будет вызван, если существует). Включается автоматически, если [method _physics_process] переопределяется. Любые вызовы этой функции до [method _ready] будут проигнорированы.
			</description>
		</method>
		<method name="set_physics_process_internal">
			<return type="void" />
			<argument index="0" name="enable" type="bool" />
			<description>
				Включает или отключает внутреннюю физику для этого узла. Внутренняя обработка физики происходит в отрыве от обычных вызовов [method _physics_process] и используется некоторыми узлами внутри, чтобы гарантировать правильное функционирование, даже если узел приостановлен или обработка физики отключена для скриптинга ([method set_physics_process]). Полезен только для расширенного использования для манипулирования поведением встроенных узлов.
				[b]Предупреждение:[/b] Встроенные ноды полагаются на внутреннюю обработку для своей собственной логики, поэтому изменение этого значения в вашем коде может привести к неожиданному поведению. Скриптовый доступ к этой внутренней логике предоставляется для специальных расширенных применений, но является небезопасным и не поддерживается.
			</description>
		</method>
		<method name="set_process">
			<return type="void" />
			<argument index="0" name="enable" type="bool" />
			<description>
				Включает или выключает обработку. Когда узел обрабатывается, он будет получать [константу NOTIFICATION_PROCESS] на каждом отрисованном кадре (и обратный вызов [method _process] будет вызван, если он существует). Включается автоматически, если [method _process] переопределен. Любые вызовы этой функции до [method _ready] будут проигнорированы.
			</description>
		</method>
		<method name="set_process_input">
			<return type="void" />
			<argument index="0" name="enable" type="bool" />
			<description>
				Включает или отключает обработку ввода. Это не требуется для элементов управления GUI! Включается автоматически, если переопределен [method _input]. Любые вызовы этого метода до [method _ready] будут проигнорированы.
			</description>
		</method>
		<method name="set_process_internal">
			<return type="void" />
			<argument index="0" name="enable" type="bool" />
			<description>
				Включает или отключает внутреннюю обработку для этого узла. Внутренняя обработка происходит в отрыве от обычных вызовов [method _process] и используется некоторыми узлами для обеспечения правильного функционирования, даже если узел приостановлен или обработка отключена для скриптинга ([method set_process]). Полезен только для расширенного использования для манипулирования поведением встроенных узлов.
				[b]Предупреждение:[/b] Встроенные узлы полагаются на внутреннюю обработку для своей собственной логики, поэтому изменение этого значения в вашем коде может привести к неожиданному поведению. Скриптовый доступ к этой внутренней логике предоставляется для специальных расширенных применений, но является небезопасным и не поддерживается.
			</description>
		</method>
		<method name="set_process_unhandled_input">
			<return type="void" />
			<argument index="0" name="enable" type="bool" />
			<description>
				Включает обработку необработанного ввода. Это не требуется для элементов управления графического интерфейса! Это позволяет узлу получать весь ввод, который не был обработан ранее (обычно с помощью [Control]). Включается автоматически, если переопределен [method _unhandled_input]. Любые вызовы этого метода до [method _ready] будут проигнорированы.
			</description>
		</method>
		<method name="set_process_unhandled_key_input">
			<return type="void" />
			<argument index="0" name="enable" type="bool" />
			<description>
				Включает обработку ввода необработанных клавиш. Включается автоматически, если переопределен [method _unhandled_key_input]. Любые вызовы этого метода до [метода _ready] будут проигнорированы.
			</description>
		</method>
		<method name="set_scene_instance_load_placeholder">
			<return type="void" />
			<argument index="0" name="load_placeholder" type="bool" />
			<description>
				Устанавливает, является ли этот экземпляр местодержателем загрузки. См. раздел [InstancePlaceholder].
			</description>
		</method>
		<method name="update_configuration_warning">
			<return type="void" />
			<description>
				Обновляет предупреждение, отображаемое для этого узла в Scene Dock.
				Используйте [метод _get_configuration_warning] для настройки отображаемого предупреждения.
			</description>
		</method>
	</methods>
	<members>
		<member name="custom_multiplayer" type="MultiplayerAPI" setter="set_custom_multiplayer" getter="get_custom_multiplayer">
			Переопределение стандартного [MultiplayerAPI]. Установите значение [code]null[/code], чтобы использовать [SceneTree] по умолчанию.
		</member>
		<member name="filename" type="String" setter="set_filename" getter="get_filename">
			Если сцена инстанцирована из файла, ее верхний узел содержит абсолютный путь к файлу, из которого она была загружена, в [member filename] (например, [code]res://levels/1.tscn[/code]). В противном случае [member filename] устанавливается в пустую строку.
		</member>
		<member name="multiplayer" type="MultiplayerAPI" setter="" getter="get_multiplayer">
			Экземпляр [MultiplayerAPI], связанный с этим узлом. Либо [member custom_multiplayer], либо стандартный экземпляр SceneTree (если он находится внутри дерева).
		</member>
		<member name="name" type="String" setter="set_name" getter="get_name">
			Имя узла. Это имя является уникальным среди сиблингов (других дочерних узлов от того же родителя). Если задано существующее имя, узел будет автоматически переименован.
			[b]Примечание:[/b] Автоматически генерируемые имена могут включать символ [code]@[/code], который зарезервирован для уникальных имен при использовании [method add_child]. При задании имени вручную все [code]@[/code] будут удалены.
		</member>
		<member name="owner" type="Node" setter="set_owner" getter="get_owner">
			Владелец узла. Владельцем узла может быть любой другой узел (при условии, что он является действительным родителем, дедушкой или бабушкой и т. д. по возрастанию в дереве). При сохранении узла (с помощью [PackedScene]) все принадлежащие ему узлы будут сохранены вместе с ним. Это позволяет создавать сложные [SceneTree]ы с инстансами и субинстансами.
			[b]Примечание:[/b] Если вы хотите, чтобы дочерний элемент сохранялся в [PackedScene], необходимо установить [member owner] в дополнение к вызову [method add_child]. Обычно это актуально для [url=$DOCS_URL/tutorials/plugins/running_code_in_the_editor.html]инструментальных скриптов[/url] и [url=$DOCS_URL/tutorials/plugins/editor/index.html]плагинов редактора[/url]. Если вызвать [метод add_child] без установки [member owner], то добавленный узел [Node] не будет виден в дереве сцены, но будет виден в 2D/3D представлении.
		</member>
		<member name="pause_mode" type="int" setter="set_pause_mode" getter="get_pause_mode" enum="Node.PauseMode" default="0">
			Режим паузы. Как будет вести себя узел, если [SceneTree] будет приостановлен.
		</member>
		<member name="physics_interpolation_mode" type="int" setter="set_physics_interpolation_mode" getter="get_physics_interpolation_mode" enum="Node.PhysicsInterpolationMode" default="0">
			Позволяет включать или отключать интерполяцию физики для каждого узла, обеспечивая более тонкий контроль, чем глобальное включение и отключение интерполяции физики.
			[b]Примечание:[/b] Это может быть особенно полезно для [Camera]s, где пользовательская интерполяция иногда может дать лучшие результаты.
		</member>
		<member name="process_priority" type="int" setter="set_process_priority" getter="get_process_priority" default="0">
			Приоритет узла в порядке выполнения включенных обратных вызовов обработки (т.е. [constant NOTIFICATION_PROCESS], [constant NOTIFICATION_PHYSICS_PROCESS] и их внутренних аналогов). Узлы, чье значение приоритета процесса [i]ниже[/i], будут выполнять свои обратные вызовы обработки первыми.
		</member>
		<member name="unique_name_in_owner" type="bool" setter="set_unique_name_in_owner" getter="is_unique_name_in_owner" default="false">
			Устанавливает имя этого узла в качестве уникального имени в его [member owner]. Это позволит обращаться к узлу как к [code]%Name[/code] вместо полного пути, из любого узла в пределах этой сцены.
			Если у другого узла с тем же владельцем имя уже объявлено уникальным, имя этого узла больше не будет устанавливаться как уникальное.
		</member>
	</members>
	<signals>
		<signal name="child_entered_tree">
			<argument index="0" name="node" type="Node" />
			<description>
				Выдается, когда дочерний узел входит в дерево сцены, либо потому что он вошел сам, либо потому что этот узел вошел вместе с ним.
				Этот сигнал испускается [i]после[/i] собственных [constant NOTIFICATION_ENTER_TREE] и [signal tree_entered] дочернего узла.
			</description>
		</signal>
		<signal name="child_exiting_tree">
			<argument index="0" name="node" type="Node" />
			<description>
				Выдается, когда дочерний узел собирается покинуть дерево сцены, либо потому что он удаляется или освобождается напрямую, либо потому что этот узел покидает дерево.
				Когда этот сигнал получен, дочерний [code]узел[/code] все еще находится в дереве и действителен. Этот сигнал выдается [i]после[/i] собственных [signal tree_exiting] и [constant NOTIFICATION_EXIT_TREE] дочернего узла.
			</description>
		</signal>
		<signal name="ready">
			<description>
				Выдается, когда узел готов.
			</description>
		</signal>
		<signal name="renamed">
			<description>
				Выдается при переименовании узла.
			</description>
		</signal>
		<signal name="tree_entered">
			<description>
				Выдается, когда узел входит в дерево.
				Этот сигнал выдается [i]после[/i] связанного с ним уведомления [constant NOTIFICATION_ENTER_TREE].
			</description>
		</signal>
		<signal name="tree_exited">
			<description>
				Выдается после того, как узел выходит из дерева и больше не активен.
			</description>
		</signal>
		<signal name="tree_exiting">
			<description>
				Выдается, когда узел все еще активен, но собирается покинуть дерево. Это подходящее место для деинициализации (или "деструктора", если хотите).
				Этот сигнал выдается [i]перед[/i] соответствующим уведомлением [constant NOTIFICATION_EXIT_TREE].
			</description>
		</signal>
	</signals>
	<constants>
		<constant name="NOTIFICATION_ENTER_TREE" value="10">
			Уведомление, получаемое, когда узел входит в [SceneTree].
			Это уведомление выдается [i]перед[/i] соответствующим [signal tree_entered].
		</constant>
		<constant name="NOTIFICATION_EXIT_TREE" value="11">
			Уведомление, получаемое, когда узел собирается выйти из [SceneTree].
			Это уведомление выдается [i]после[/i] связанного [сигнала tree_exiting].
		</constant>
		<constant name="NOTIFICATION_MOVED_IN_PARENT" value="12">
			Уведомление, получаемое при перемещении узла в родителе.
		</constant>
		<constant name="NOTIFICATION_READY" value="13">
			Уведомление, получаемое, когда узел готов. См. раздел [метод _ready].
		</constant>
		<constant name="NOTIFICATION_PAUSED" value="14">
			Уведомление, получаемое, когда узел приостанавливается.
		</constant>
		<constant name="NOTIFICATION_UNPAUSED" value="15">
			Уведомление, получаемое при снятии узла с паузы.
		</constant>
		<constant name="NOTIFICATION_PHYSICS_PROCESS" value="16">
			Уведомление, получаемое каждый кадр, когда установлен флаг физического процесса (см. [method set_physics_process]).
		</constant>
		<constant name="NOTIFICATION_PROCESS" value="17">
			Уведомление, получаемое каждый кадр, когда установлен флаг процесса (см. [метод set_process]).
		</constant>
		<constant name="NOTIFICATION_PARENTED" value="18">
			Уведомление, получаемое, когда узел становится дочерним по отношению к другому узлу.
			[b]Примечание:[/b] Это не означает, что узел вошел в [SceneTree].
		</constant>
		<constant name="NOTIFICATION_UNPARENTED" value="19">
			Уведомление, получаемое, когда узел лишается родительских прав (родитель удаляет его из списка дочерних узлов).
		</constant>
		<constant name="NOTIFICATION_INSTANCED" value="20">
			Уведомление, получаемое при инстанцировании узла.
		</constant>
		<constant name="NOTIFICATION_DRAG_BEGIN" value="21">
			Уведомление, получаемое при начале операции перетаскивания. Это уведомление получают все узлы, а не только перетаскиваемый.
			Может быть вызвано либо перетаскиванием [Control], который предоставляет данные о перетаскивании (см. [method Control.get_drag_data]), либо с помощью [method Control.force_drag].
			Для получения данных о перетаскивании используйте [метод Viewport.gui_get_drag_data].
		</constant>
		<constant name="NOTIFICATION_DRAG_END" value="22">
			Уведомление, получаемое при завершении операции перетаскивания.
			Для проверки успешности перетаскивания используйте [метод Viewport.gui_is_drag_successful].
		</constant>
		<constant name="NOTIFICATION_PATH_CHANGED" value="23">
			Уведомление, полученное при изменении [NodePath] узла.
		</constant>
		<constant name="NOTIFICATION_INTERNAL_PROCESS" value="25">
			Уведомление, получаемое каждый кадр, когда установлен флаг внутреннего процесса (см. [метод set_process_internal]).
		</constant>
		<constant name="NOTIFICATION_INTERNAL_PHYSICS_PROCESS" value="26">
			Уведомление, получаемое каждый кадр, когда установлен флаг внутреннего физического процесса (см. [method set_physics_process_internal]).
		</constant>
		<constant name="NOTIFICATION_POST_ENTER_TREE" value="27">
			Уведомление, получаемое, когда узел готов, непосредственно перед получением [constant NOTIFICATION_READY]. В отличие от последнего, оно отправляется каждый раз, когда узел входит в дерево, а не только один раз.
		</constant>
		<constant name="NOTIFICATION_RESET_PHYSICS_INTERPOLATION" value="28">
			Уведомление, получаемое при вызове [метода reset_physics_interpolation] на узле или родительских узлах.
		</constant>
		<constant name="NOTIFICATION_WM_MOUSE_ENTER" value="1002">
			Уведомление, получаемое от ОС, когда мышь попадает в игровое окно.
			Реализовано на настольных и веб-платформах.
		</constant>
		<constant name="NOTIFICATION_WM_MOUSE_EXIT" value="1003">
			Уведомление, получаемое от ОС, когда мышь покидает игровое окно.
			Реализовано на настольных и веб-платформах.
		</constant>
		<constant name="NOTIFICATION_WM_FOCUS_IN" value="1004">
			Уведомление, получаемое от ОС при фокусировке окна игры.
			Реализовано на всех платформах.
		</constant>
		<constant name="NOTIFICATION_WM_FOCUS_OUT" value="1005">
			Уведомление, получаемое от ОС при расфокусировке окна игры.
			Реализовано на всех платформах.
		</constant>
		<constant name="NOTIFICATION_WM_QUIT_REQUEST" value="1006">
			Уведомление, получаемое от ОС при отправке запроса на выход (например, закрытие окна с помощью кнопки "Закрыть" или Alt+F4).
			Реализовано на настольных платформах.
		</constant>
		<constant name="NOTIFICATION_WM_GO_BACK_REQUEST" value="1007">
			Уведомление, получаемое от ОС при отправке запроса на возврат (например, нажатие кнопки "Назад" на Android).
			Специфично для платформы Android.
		</constant>
		<constant name="NOTIFICATION_WM_UNFOCUS_REQUEST" value="1008">
			Уведомление, получаемое от ОС, когда отправляется запрос на расфокусировку (например, другое окно ОС хочет захватить фокус).
			В настоящее время ни одна из поддерживаемых платформ не отправляет это уведомление.
		</constant>
		<constant name="NOTIFICATION_OS_MEMORY_WARNING" value="1009">
			Уведомление, получаемое от ОС, когда приложение превышает выделенную ему память.
			Специфично для платформы iOS.
		</constant>
		<constant name="NOTIFICATION_TRANSLATION_CHANGED" value="1010">
			Уведомление о возможном изменении перевода. Может быть вызвано изменением локали пользователем. Может использоваться для реагирования на изменение языка, например, для изменения строк пользовательского интерфейса на лету. Полезно при работе со встроенной поддержкой переводов, например [метод Object.tr].
		</constant>
		<constant name="NOTIFICATION_WM_ABOUT" value="1011">
			Уведомление, получаемое от ОС при отправке запроса на информацию "О программе".
			Специфично для платформы macOS.
		</constant>
		<constant name="NOTIFICATION_CRASH" value="1012">
			Уведомление, получаемое от обработчика сбоев Godot, когда движок вот-вот упадет.
			Реализовано на настольных платформах, если обработчик сбоев включен.
		</constant>
		<constant name="NOTIFICATION_OS_IME_UPDATE" value="1013">
			Уведомление, получаемое от ОС при обновлении механизма метода ввода (например, изменение положения курсора IME или строки композиции).
			Специфично для платформы macOS.
		</constant>
		<constant name="NOTIFICATION_APP_RESUMED" value="1014">
			Уведомление, получаемое от ОС при возобновлении работы приложения.
			Специфично для платформы Android.
		</constant>
		<constant name="NOTIFICATION_APP_PAUSED" value="1015">
			Уведомление, получаемое от ОС, когда приложение приостанавливается.
			Специфично для платформы Android.
		</constant>
		<constant name="PAUSE_MODE_INHERIT" value="0" enum="PauseMode">
			Наследует режим паузы от родительского узла. Для корневого узла эквивалентно [constant PAUSE_MODE_STOP]. По умолчанию.
		</constant>
		<constant name="PAUSE_MODE_STOP" value="1" enum="PauseMode">
			Остановка обработки при приостановке [SceneTree].
		</constant>
		<constant name="PAUSE_MODE_PROCESS" value="2" enum="PauseMode">
			Продолжайте обработку независимо от состояния паузы [SceneTree].
		</constant>
		<constant name="PHYSICS_INTERPOLATION_MODE_INHERIT" value="0" enum="PhysicsInterpolationMode">
			Наследует режим интерполяции физики от родительского узла. Для корневого узла это эквивалентно [constant PHYSICS_INTERPOLATION_MODE_ON]. По умолчанию.
		</constant>
		<constant name="PHYSICS_INTERPOLATION_MODE_OFF" value="1" enum="PhysicsInterpolationMode">
			Отключите интерполяцию физики в этом узле, а для дочерних узлов установите значение [constant PHYSICS_INTERPOLATION_MODE_INHERIT].
		</constant>
		<constant name="PHYSICS_INTERPOLATION_MODE_ON" value="2" enum="PhysicsInterpolationMode">
			Включите интерполяцию физики в этом узле, а для дочерних узлов установите значение [constant PHYSICS_INTERPOLATION_MODE_INHERIT].
		</constant>
		<constant name="DUPLICATE_SIGNALS" value="1" enum="DuplicateFlags">
			Дублирует сигналы узла.
		</constant>
		<constant name="DUPLICATE_GROUPS" value="2" enum="DuplicateFlags">
			Дублирование групп узла.
		</constant>
		<constant name="DUPLICATE_SCRIPTS" value="4" enum="DuplicateFlags">
			Дублирование скриптов узла.
		</constant>
		<constant name="DUPLICATE_USE_INSTANCING" value="8" enum="DuplicateFlags">
			Дублирование с помощью инстансирования.
			Экземпляр остается связанным с оригиналом, поэтому при изменении оригинала меняется и экземпляр.
		</constant>
	</constants>
</class>
