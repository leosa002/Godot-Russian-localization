<?xml version="1.0" encoding="UTF-8" ?>
<class name="Control" inherits="CanvasItem" version="3.5" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../class.xsd">
	<brief_description>
		Все узлы пользовательского интерфейса наследуются от Control. Якоря и поля элемента управления определяют его положение и размер относительно родителя.
	</brief_description>
	<description>
		Базовый класс для всех узлов, связанных с пользовательским интерфейсом. Узел [Control] имеет ограничивающий прямоугольник, определяющий его границы, положение якоря относительно родительского элемента управления или текущего пространства просмотра, а также поля, представляющие собой смещение относительно якоря. Поля автоматически обновляются при изменении узла, его родителей или размера экрана.
		Более подробную информацию о системе пользовательского интерфейса Godot, якорях, полях и контейнерах можно найти в соответствующих разделах руководства. Для создания гибкого пользовательского интерфейса вам понадобится набор элементов пользовательского интерфейса, которые наследуются от узлов [Control] и [Container].
		[b]Узлы пользовательского интерфейса и ввод[/b]
		Сначала Godot отправляет события ввода в корневой узел сцены, вызывая [method Node._input]. [method Node._input] направляет событие вниз по дереву узлов к узлам, находящимся под курсором мыши или в фокусе клавиатуры. Для этого он вызывает [метод MainLoop._input_event]. Вызовите [метод accept_event], чтобы ни один другой узел не получил событие. Как только вы принимаете ввод, он становится обработанным, поэтому [метод Node._unhandled_input] не будет его обрабатывать.
		В фокусе клавиатуры может находиться только один узел [Control]. Только узел, находящийся в фокусе, будет получать события клавиатуры. Чтобы получить фокус, вызовите [метод grab_focus]. Узлы [Control] теряют фокус, когда другой узел захватывает его, или если вы скрываете узел в фокусе.
		Устанавливает [member mouse_filter] в [constant MOUSE_FILTER_IGNORE], чтобы указать узлу [Control] игнорировать события от мыши или прикосновения. Он понадобится, если вы поместите иконку поверх кнопки.
		Ресурсы [Theme] изменяют внешний вид элемента управления. Если вы измените тему [Theme] на узле [Control], это повлияет на все его дочерние узлы. Чтобы переопределить некоторые параметры темы, вызовите один из методов [code]add_*_override[/code], например [method add_font_override]. Вы можете переопределить тему с помощью инспектора.
		[b]Примечание:[/b] Элементы темы - это [i]не[/i] [объектные] свойства. Это означает, что вы не можете получить доступ к их значениям с помощью [method Object.get] и [method Object.set]. Вместо этого используйте [метод get_color], [метод get_constant], [метод get_font], [метод get_icon], [метод get_stylebox], а также методы [code]add_*_override[/code], предоставляемые этим классом.
	</description>
	<tutorials>
		<link title="GUI tutorial index">$DOCS_URL/tutorials/ui/index.html</link>
		<link title="Custom drawing in 2D">$DOCS_URL/tutorials/2d/custom_drawing_in_2d.html</link>
		<link title="Control node gallery">$DOCS_URL/tutorials/ui/control_node_gallery.html</link>
		<link title="All GUI Demos">https://github.com/godotengine/godot-demo-projects/tree/master/gui</link>
	</tutorials>
	<methods>
		<method name="_clips_input" qualifiers="virtual">
			<return type="bool" />
			<description>
				Виртуальный метод, который должен быть реализован пользователем. Возвращает, должен ли [метод _gui_input] не вызываться для дочерних элементов управления за пределами прямоугольника этого элемента управления. Ввод будет обрезан по Rect этого [Control]. Аналогично [члену rect_clip_content], но не влияет на видимость.
				Если не переопределено, по умолчанию принимает значение [code]false[/code].
			</description>
		</method>
		<method name="_get_minimum_size" qualifiers="virtual">
			<return type="Vector2" />
			<description>
				Виртуальный метод, который должен быть реализован пользователем. Возвращает минимальный размер для данного элемента управления. Альтернатива [member rect_min_size] для управления минимальным размером через код. Фактический минимальный размер будет равен максимальному значению из этих двух (по каждой оси отдельно).
				Если не переопределено, по умолчанию принимает значение [constant Vector2.ZERO].
				[b]Примечание:[/b] Этот метод не будет вызван, если скрипт прикреплен к узлу [Control], который уже переопределяет свой минимальный размер (например, [Label], [Button], [PanelContainer] и т.д.). Его можно использовать только с самыми основными узлами GUI, такими как [Control], [Container], [Panel] и т. д.
			</description>
		</method>
		<method name="_gui_input" qualifiers="virtual">
			<return type="void" />
			<argument index="0" name="event" type="InputEvent" />
			<description>
				Виртуальный метод, который должен быть реализован пользователем. Используйте этот метод для обработки и приема входных данных на элементах пользовательского интерфейса. См. раздел [method accept_event].
				Пример: щелчок по элементу управления.
				[codeblock]
				func _gui_input(event):
				    if event is InputEventMouseButton:
				        if event.button_index == BUTTON_LEFT and event.pressed:
				            print("На меня нажали D:")
				[/codeblock]
				Событие не сработает, если:
				* щелчок за пределами элемента управления (см. [метод has_point]);
				* элемент управления имеет [member mouse_filter], установленный на [constant MOUSE_FILTER_IGNORE];
				* контролу мешает другой [Control], расположенный поверх него, у которого [member mouse_filter] не установлен на [constant MOUSE_FILTER_IGNORE];
				* родитель элемента управления имеет [member mouse_filter], установленный на [constant MOUSE_FILTER_STOP] или принял событие;
				* это происходит за пределами прямоугольника родителя, и у родителя включен либо [член rect_clip_content], либо [метод _clips_input].
				[b]Примечание:[/b] Положение события относительно начала элемента управления.
			</description>
		</method>
		<method name="_make_custom_tooltip" qualifiers="virtual">
			<return type="Control" />
			<argument index="0" name="for_text" type="String" />
			<description>
				Виртуальный метод, который должен быть реализован пользователем. Возвращает узел [Control], который должен быть использован в качестве всплывающей подсказки вместо стандартной. В [code]for_text[/code] входит содержимое свойства [member hint_tooltip].
				Возвращаемый узел должен быть типа [Control] или производным от Control. Он может иметь дочерние узлы любого типа. Он освобождается, когда подсказка исчезает, поэтому убедитесь, что вы всегда предоставляете новый экземпляр (если вы хотите использовать уже существующий узел из дерева сцены, вы можете продублировать его и передать продублированный экземпляр). Если возвращается [code]null[/code] или неконтрольный узел, вместо него будет использована всплывающая подсказка по умолчанию.
				Возвращаемый узел будет добавлен в качестве дочернего в [PopupPanel], поэтому вы должны предоставить только содержимое этой панели. Эта [PopupPanel] может быть оформлена с помощью [метод Theme.set_stylebox] для типа [code]"TooltipPanel"[/code] (см. пример в [member hint_tooltip]).
				[b]Примечание:[/b] Всплывающая подсказка уменьшается до минимального размера. Если вы хотите, чтобы она была видна полностью, вам следует установить для ее [member rect_min_size] ненулевое значение.
				Пример использования с пользовательским узлом:
				[codeblock]
				func _make_custom_tooltip(for_text):
				    var label = Label.new()
				    label.text = for_text
				    return label
				[/codeblock]
				Пример использования с пользовательским экземпляром сцены:
				[codeblock]
				func _make_custom_tooltip(for_text):
				    var tooltip = preload("res://SomeTooltipScene.tscn").instance()
				    tooltip.get_node("Label").text = for_text
				    return tooltip
				[/codeblock]
			</description>
		</method>
		<method name="accept_event">
			<return type="void" />
			<description>
				Помечает событие ввода как обработанное. Как только вы принимаете событие ввода, оно перестает распространяться, даже на узлы, слушающие [метод Node._unhandled_input] или [метод Node._unhandled_key_input].
			</description>
		</method>
		<method name="add_color_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="color" type="Color" />
			<description>
				Создает локальное переопределение для темы [Color] с указанным [code]именем[/code]. Локальные переопределения всегда имеют приоритет при получении элементов темы для элемента управления.
				См. также [метод get_color], [метод remove_color_override].
				[b]Пример переопределения цвета метки и его последующего сброса:[/b]
				[codeblock]
				# Получив дочерний узел Label "MyLabel", переопределите цвет его шрифта с помощью пользовательского значения.
				$MyLabel.add_color_override("font_color", Color(1, 0.5, 0))
				# Сбросьте цвет шрифта дочерней метки.
				$MyLabel.add_color_override("font_color", get_color("font_color", "Label"))
				[/codeblock]
			</description>
		</method>
		<method name="add_constant_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="constant" type="int" />
			<description>
				Создает локальное переопределение для константы темы с указанным [code]именем[/code]. Локальные переопределения всегда имеют приоритет при получении элементов темы для элемента управления.
				См. также [метод get_constant], [метод remove_constant_override].
			</description>
		</method>
		<method name="add_font_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="font" type="Font" />
			<description>
				Создает локальное переопределение для темы [Font] с указанным [code]именем[/code]. Локальные переопределения всегда имеют приоритет при получении элементов темы для элемента управления.
				[b]Примечание:[/b] Переопределение можно удалить, присвоив ему значение [code]null[/code]. Это поведение устарело и будет удалено в версии 4.0, используйте вместо этого [метод remove_font_override].
				См. также [метод get_font].
			</description>
		</method>
		<method name="add_icon_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="texture" type="Texture" />
			<description>
				Создает локальное переопределение для значка темы с указанным [code]именем[/code]. Локальные переопределения всегда имеют приоритет при получении элементов темы для элемента управления.
				[b]Примечание:[/b] Переопределение можно удалить, присвоив ему значение [code]null[/code]. Это поведение устарело и будет удалено в версии 4.0, используйте вместо этого [метод remove_icon_override].
				См. также [метод get_icon].
			</description>
		</method>
		<method name="add_shader_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="shader" type="Shader" />
			<description>
				Создает локальное переопределение для шейдера темы с указанным [code]именем[/code]. Локальные переопределения всегда имеют приоритет при получении элементов темы для элемента управления.
				[b]Примечание:[/b] Переопределение можно удалить, присвоив ему значение [code]null[/code]. Это поведение устарело и будет удалено в 4.0, используйте вместо этого [метод remove_shader_override].
			</description>
		</method>
		<method name="add_stylebox_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="stylebox" type="StyleBox" />
			<description>
				Создает локальное переопределение для темы [StyleBox] с указанным [code]именем[/code]. Локальные переопределения всегда имеют приоритет при получении элементов темы для элемента управления.
				[b]Примечание:[/b] Переопределение можно удалить, присвоив ему значение [code]null[/code]. Это поведение устарело и будет удалено в версии 4.0, используйте вместо этого [метод remove_stylebox_override].
				См. также [метод get_stylebox].
				[b]Пример изменения свойства в StyleBox путем его дублирования:[/b]
				[codeblock]
				# В приведенном ниже фрагменте предполагается, что дочернему узлу MyButton назначен StyleBoxFlat.
				# Ресурсы разделяются между экземплярами, поэтому нам нужно продублировать его.
				# чтобы избежать изменения внешнего вида всех остальных кнопок.
				var new_stylebox_normal = $MyButton.get_stylebox("normal").duplicate()
				new_stylebox_normal.border_width_top = 3
				new_stylebox_normal.border_color = Color(0, 1, 0.5)
				$MyButton.add_stylebox_override("normal", new_stylebox_normal)
				# Удалите переопределение стилей.
				$MyButton.add_stylebox_override("normal", null)
				[/codeblock]
			</description>
		</method>
		<method name="can_drop_data" qualifiers="virtual">
			<return type="bool" />
			<argument index="0" name="position" type="Vector2" />
			<argument index="1" name="data" type="Variant" />
			<description>
				Godot вызывает этот метод, чтобы проверить, могут ли [code]данные[/code] из [метода get_drag_data] элемента управления быть сброшены в [code]позицию[/code]. [code]позиция[/code] является локальной для данного элемента управления.
				Этот метод следует использовать только для проверки данных. Обработайте данные в [методе drop_data].
				[codeblock]
				func can_drop_data(position, data):
				    # Проверьте позицию, если она имеет для вас значение.
				    # В противном случае просто проверьте данные
				    return typeof(data) == TYPE_DICTIONARY and data.has("expected")
				[/codeblock]
			</description>
		</method>
		<method name="drop_data" qualifiers="virtual">
			<return type="void" />
			<argument index="0" name="position" type="Vector2" />
			<argument index="1" name="data" type="Variant" />
			<description>
				Godot вызывает этот метод, чтобы передать вам [code]данные[/code] из результата [method get_drag_data] элемента управления. Сначала Godot вызывает [метод can_drop_data], чтобы проверить, разрешено ли падение [code]data[/code] в [code]position[/code], где [code]position[/code] является локальным для данного элемента управления.
				[codeblock]
				func can_drop_data(position, data):
				    return typeof(data) == TYPE_DICTIONARY and data.has("color")

				func drop_data(position, data):
				    color = data["color"]
				[/codeblock]
			</description>
		</method>
		<method name="find_next_valid_focus" qualifiers="const">
			<return type="Control" />
			<description>
				Находит следующий (ниже в дереве) [Control], который может получить фокус.
			</description>
		</method>
		<method name="find_prev_valid_focus" qualifiers="const">
			<return type="Control" />
			<description>
				Находит предыдущий (выше в дереве) [Control], который может получить фокус.
			</description>
		</method>
		<method name="force_drag">
			<return type="void" />
			<argument index="0" name="data" type="Variant" />
			<argument index="1" name="preview" type="Control" />
			<description>
				Принуждает к перетаскиванию и обходит [метод get_drag_data] и [метод set_drag_preview], передавая [code]data[/code] и [code]preview[/code]. Перетаскивание начнется, даже если мышь не наведена и не нажата на этом элементе управления.
				Методы [method can_drop_data] и [method drop_data] должны быть реализованы в элементах управления, которые хотят получать данные о перетаскивании.
			</description>
		</method>
		<method name="get_anchor" qualifiers="const">
			<return type="float" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<description>
				Возвращает якорь, идентифицированный константой [code]margin[/code] из перечисления [enum Margin]. Метод получения для [member anchor_bottom], [member anchor_left], [member anchor_right] и [member anchor_top].
			</description>
		</method>
		<method name="get_begin" qualifiers="const">
			<return type="Vector2" />
			<description>
				Возвращает значения [member margin_left] и [member margin_top]. См. также [member rect_position].
			</description>
		</method>
		<method name="get_color" qualifiers="const">
			<return type="Color" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="theme_type" type="String" default="&quot;&quot;" />
			<description>
				Возвращает [Color] из первой подходящей [Theme] в дереве, если в этой [Theme] есть элемент цвета с указанными [code]name[/code] и [code]theme_type[/code]. Если [code]theme_type[/code] опущен, в качестве типа используется имя класса текущего элемента управления или [member theme_type_variation], если он определен. Если тип является именем класса, проверяются также его родительские классы в порядке наследования.
				Для текущего элемента управления сначала рассматриваются его локальные переопределения (см. [метод add_color_override]), затем назначенная ему [member Theme]. После текущего элемента управления рассматривается каждый родительский элемент управления и назначенная ему [member Theme]; элементы управления без назначенной [member Theme] пропускаются. Если в дереве не найдена подходящая [Theme], используется пользовательская [Theme] проекта (см. [member ProjectSettings.gui/theme/custom]) и [Theme] по умолчанию.
				[codeblock]
				func _ready():
				    # Получает цвет шрифта, определенный для класса текущего Control, если он существует.
				    modulate = get_color("font_color")
				    # Получение цвета шрифта, определенного для класса Button.
				    modulate = get_color("font_color", "Button")
				[/codeblock]
			</description>
		</method>
		<method name="get_combined_minimum_size" qualifiers="const">
			<return type="Vector2" />
			<description>
				Возвращает комбинированный минимальный размер из [member rect_min_size] и [method get_minimum_size].
			</description>
		</method>
		<method name="get_constant" qualifiers="const">
			<return type="int" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="theme_type" type="String" default="&quot;&quot;" />
			<description>
				Возвращает константу из первой подходящей [Theme] в дереве, если в этой [Theme] есть элемент константы с указанными [code]name[/code] и [code]theme_type[/code].
				Подробности см. в [методе get_color].
			</description>
		</method>
		<method name="get_cursor_shape" qualifiers="const">
			<return type="int" enum="Control.CursorShape" />
			<argument index="0" name="position" type="Vector2" default="Vector2( 0, 0 )" />
			<description>
				Возвращает форму курсора мыши, которую элемент управления отображает при наведении мыши. См. раздел [enum CursorShape].
			</description>
		</method>
		<method name="get_drag_data" qualifiers="virtual">
			<return type="Variant" />
			<argument index="0" name="position" type="Vector2" />
			<description>
				Godot вызывает этот метод, чтобы получить данные, которые можно перетащить на элементы управления, ожидающие данных для перетаскивания. Возвращает [code]null[/code], если нет данных для перетаскивания. Элементы управления, которые хотят получать данные для перетаскивания, должны реализовать [метод can_drop_data] и [метод drop_data]. [code]position[/code] является локальным для данного элемента управления. Перетаскивание может быть принудительным с помощью [method force_drag].
				Предварительный просмотр, который будет следовать за мышью и представлять данные, может быть установлен с помощью [method set_drag_preview]. Самое подходящее время для установки предварительного просмотра - этот метод.
				[codeblock]
				func get_drag_data(position):
				    var mydata = make_data()
				    set_drag_preview(make_preview(mydata))
				    return mydata
				[/codeblock]
			</description>
		</method>
		<method name="get_end" qualifiers="const">
			<return type="Vector2" />
			<description>
				Возвращает [member margin_right] и [member margin_bottom].
			</description>
		</method>
		<method name="get_focus_neighbour" qualifiers="const">
			<return type="NodePath" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<description>
				Возвращает соседа по фокусу, идентифицированного константой [code]margin[/code] из перечисления [enum Margin]. Метод получения для [member focus_neighbour_bottom], [member focus_neighbour_left], [member focus_neighbour_right] и [member focus_neighbour_top].
			</description>
		</method>
		<method name="get_focus_owner" qualifiers="const">
			<return type="Control" />
			<description>
				Возвращает элемент управления, имеющий фокус клавиатуры, или [code]null[/code], если он отсутствует.
			</description>
		</method>
		<method name="get_font" qualifiers="const">
			<return type="Font" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="theme_type" type="String" default="&quot;&quot;" />
			<description>
				Возвращает [Font] из первой подходящей [Theme] в дереве, если в этой [Theme] есть элемент шрифта с указанными [code]name[/code] и [code]theme_type[/code].
				Подробности см. в [методе get_color].
			</description>
		</method>
		<method name="get_global_rect" qualifiers="const">
			<return type="Rect2" />
			<description>
				Возвращает положение и размер элемента управления относительно левого верхнего угла экрана. См. [член rect_position] и [член rect_size].
			</description>
		</method>
		<method name="get_icon" qualifiers="const">
			<return type="Texture" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="theme_type" type="String" default="&quot;&quot;" />
			<description>
				Возвращает иконку из первой подходящей [Theme] в дереве, если в этой [Theme] есть элемент иконки с указанными [code]name[/code] и [code]theme_type[/code].
				Подробности см. в [методе get_color].
			</description>
		</method>
		<method name="get_margin" qualifiers="const">
			<return type="float" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<description>
				Возвращает якорь, идентифицированный константой [code]margin[/code] из перечисления [enum Margin]. Метод получения для [member margin_bottom], [member margin_left], [member margin_right] и [member margin_top].
			</description>
		</method>
		<method name="get_minimum_size" qualifiers="const">
			<return type="Vector2" />
			<description>
				Возвращает минимальный размер для этого элемента управления. См. раздел [member rect_min_size].
			</description>
		</method>
		<method name="get_parent_area_size" qualifiers="const">
			<return type="Vector2" />
			<description>
				Возвращает ширину/высоту, занимаемую в родительском элементе управления.
			</description>
		</method>
		<method name="get_parent_control" qualifiers="const">
			<return type="Control" />
			<description>
				Возвращает родительский узел управления.
			</description>
		</method>
		<method name="get_rect" qualifiers="const">
			<return type="Rect2" />
			<description>
				Возвращает положение и размер элемента управления относительно левого верхнего угла родительского элемента управления. См. [член rect_position] и [член rect_size].
			</description>
		</method>
		<method name="get_rotation" qualifiers="const">
			<return type="float" />
			<description>
				Возвращает вращение (в радианах).
			</description>
		</method>
		<method name="get_stylebox" qualifiers="const">
			<return type="StyleBox" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="theme_type" type="String" default="&quot;&quot;" />
			<description>
				Возвращает [StyleBox] из первой подходящей [Theme] в дереве, если в этой [Theme] есть элемент stylebox с указанными [code]name[/code] и [code]theme_type[/code].
				Подробности см. в [методе get_color].
			</description>
		</method>
		<method name="get_theme_default_font" qualifiers="const">
			<return type="Font" />
			<description>
				Возвращает шрифт по умолчанию из первой подходящей [Theme] в дереве, если эта [Theme] имеет действительное значение [member Theme.default_font].
				Подробности см. в [методе get_color].
			</description>
		</method>
		<method name="get_tooltip" qualifiers="const">
			<return type="String" />
			<argument index="0" name="at_position" type="Vector2" default="Vector2( 0, 0 )" />
			<description>
				Возвращает подсказку, которая будет появляться при наведении курсора на этот элемент управления. Смотрите [член hint_tooltip].
			</description>
		</method>
		<method name="grab_click_focus">
			<return type="void" />
			<description>
				Создает событие [InputEventMouseButton], которое пытается щелкнуть элемент управления. Если событие получено, элемент управления получает фокус.
				[codeblock]
				func _process(delta):
				    grab_click_focus() #При щелчке на другом узле управления вместо него будет щелкнут этот узел
				[/codeblock]
			</description>
		</method>
		<method name="grab_focus">
			<return type="void" />
			<description>
				Перехватывает фокус у другого элемента управления и становится фокусируемым элементом управления (см. [member focus_mode]).
				[b]Примечание[/b]: Использование этого метода вместе с [метод Object.call_deferred] делает его более надежным, особенно когда он вызывается внутри [метод Node._ready].
			</description>
		</method>
		<method name="has_color" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="theme_type" type="String" default="&quot;&quot;" />
			<description>
				Возвращает [code]true[/code], если в дереве есть подходящая [Theme], в которой есть элемент цвета с указанными [code]name[/code] и [code]theme_type[/code].
				Подробности см. в разделе [метод get_color].
			</description>
		</method>
		<method name="has_color_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<description>
				Возвращает [code]true[/code], если в данном узле [Control] существует локальное переопределение темы [Color] с указанным [code]именем[/code].
				Смотрите [метод add_color_override].
			</description>
		</method>
		<method name="has_constant" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="theme_type" type="String" default="&quot;&quot;" />
			<description>
				Возвращает [code]true[/code], если в дереве есть подходящая [Theme], которая имеет константный элемент с указанными [code]именем[/code] и [code]theme_type[/code].
				Подробности см. в [методе get_color].
			</description>
		</method>
		<method name="has_constant_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<description>
				Возвращает [code]true[/code], если в данном узле [Control] существует локальное переопределение константы темы с указанным [code]именем[/code].
				Смотрите [метод add_constant_override].
			</description>
		</method>
		<method name="has_focus" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если этот элемент управления сфокусирован в данный момент. См. раздел [member focus_mode].
			</description>
		</method>
		<method name="has_font" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="theme_type" type="String" default="&quot;&quot;" />
			<description>
				Возвращает [code]true[/code], если в дереве есть подходящая [Theme], в которой есть элемент шрифта с указанными [code]name[/code] и [code]theme_type[/code].
				Подробности см. в [методе get_color].
			</description>
		</method>
		<method name="has_font_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<description>
				Возвращает [code]true[/code], если в данном узле [Control] существует локальное переопределение темы [Font] с указанным [code]именем[/code].
				Смотрите [метод add_font_override].
			</description>
		</method>
		<method name="has_icon" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="theme_type" type="String" default="&quot;&quot;" />
			<description>
				Возвращает [code]true[/code], если в дереве есть подходящая [Theme], которая имеет элемент иконки с указанными [code]именем[/code] и [code]theme_type[/code].
				Подробности см. в [методе get_color].
			</description>
		</method>
		<method name="has_icon_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<description>
				Возвращает [code]true[/code], если в данном узле [Control] существует локальное переопределение для иконки темы с указанным [code]именем[/code].
				Смотрите [метод add_icon_override].
			</description>
		</method>
		<method name="has_point" qualifiers="virtual">
			<return type="bool" />
			<argument index="0" name="point" type="Vector2" />
			<description>
				Виртуальный метод, который должен быть реализован пользователем. Возвращает, находится ли заданная [code]точка[/code] внутри данного элемента управления.
				Если метод не переопределен, то по умолчанию проверяется, находится ли точка внутри Rect элемента управления.
				[b]Примечание:[/b] Если вы хотите проверить, находится ли точка внутри элемента управления, вы можете использовать [code]get_rect().has_point(point)[/code].
			</description>
		</method>
		<method name="has_shader_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<description>
				Возвращает [code]true[/code], если в данном узле [Control] существует локальное переопределение шейдера темы с указанным [code]именем[/code].
				Смотрите [метод add_shader_override].
			</description>
		</method>
		<method name="has_stylebox" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<argument index="1" name="theme_type" type="String" default="&quot;&quot;" />
			<description>
				Возвращает [code]true[/code], если в дереве есть подходящая [Theme], у которой есть элемент stylebox с указанными [code]name[/code] и [code]theme_type[/code].
				Подробности см. в [методе get_color].
			</description>
		</method>
		<method name="has_stylebox_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="String" />
			<description>
				Возвращает [code]true[/code], если в данном узле [Control] существует локальное переопределение темы [StyleBox] с указанным [code]именем[/code].
				Смотрите [метод add_stylebox_override].
			</description>
		</method>
		<method name="is_drag_successful" qualifiers="const">
			<return type="bool" />
			<description>
				Возвращает [code]true[/code], если операция перетаскивания прошла успешно. Альтернатива [методу Viewport.gui_is_drag_successful].
				Лучше всего использовать с [константой Node.NOTIFICATION_DRAG_END].
			</description>
		</method>
		<method name="minimum_size_changed">
			<return type="void" />
			<description>
				Аннулирует кэш размеров в этом узле и в родительских узлах до верхнего уровня. Предназначен для использования с [методом get_minimum_size], когда возвращаемое значение изменяется. Установка [member rect_min_size] напрямую вызывает этот метод автоматически.
			</description>
		</method>
		<method name="release_focus">
			<return type="void" />
			<description>
				Передайте фокус. Ни один элемент управления не сможет получать ввод с клавиатуры.
			</description>
		</method>
		<method name="remove_color_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<description>
				Удаляет переопределение темы для [Color] с заданным [code]именем[/code].
			</description>
		</method>
		<method name="remove_constant_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<description>
				Удаляет переопределение темы для константы с заданным [code]именем[/code].
			</description>
		</method>
		<method name="remove_font_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<description>
				Удаляет переопределение темы для [Font] с заданным [code]именем[/code].
			</description>
		</method>
		<method name="remove_icon_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<description>
				Удаляет переопределение темы для иконки с заданным [code]именем[/code].
			</description>
		</method>
		<method name="remove_shader_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<description>
				Удаляет переопределение темы для шейдера с заданным [code]именем[/code].
			</description>
		</method>
		<method name="remove_stylebox_override">
			<return type="void" />
			<argument index="0" name="name" type="String" />
			<description>
				Удаляет переопределение темы для [StyleBox] с заданным [code]именем[/code].
			</description>
		</method>
		<method name="set_anchor">
			<return type="void" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<argument index="1" name="anchor" type="float" />
			<argument index="2" name="keep_margin" type="bool" default="false" />
			<argument index="3" name="push_opposite_anchor" type="bool" default="true" />
			<description>
				Устанавливает якорь, идентифицированный константой [code]margin[/code] из перечисления [enum Margin], в значение [code]anchor[/code]. Метод-установщик для [member anchor_bottom], [member anchor_left], [member anchor_right] и [member anchor_top].
				Если [code]keep_margin[/code] имеет значение [code]true[/code], поля не обновляются после этой операции.
				Если [code]push_opposite_anchor[/code] имеет значение [code]true[/code] и противоположный якорь перекрывает этот якорь, то его значение будет переопределено. Например, при установке левого якоря в 1, а правый якорь имеет значение 0,5, правый якорь также получит значение 1. Если бы [code]push_opposite_anchor[/code] был [code]false[/code], левый якорь получил бы значение 0,5.
			</description>
		</method>
		<method name="set_anchor_and_margin">
			<return type="void" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<argument index="1" name="anchor" type="float" />
			<argument index="2" name="offset" type="float" />
			<argument index="3" name="push_opposite_anchor" type="bool" default="false" />
			<description>
				Работает так же, как и [method set_anchor], но вместо аргумента [code]keep_margin[/code] и автоматического обновления margin, позволяет самостоятельно задать смещение margin (см. [method set_margin]).
			</description>
		</method>
		<method name="set_anchors_and_margins_preset">
			<return type="void" />
			<argument index="0" name="preset" type="int" enum="Control.LayoutPreset" />
			<argument index="1" name="resize_mode" type="int" enum="Control.LayoutPresetMode" default="0" />
			<argument index="2" name="margin" type="int" default="0" />
			<description>
				Устанавливает предустановку якорей и предустановку полей. См. [метод set_anchors_preset] и [метод set_margins_preset].
			</description>
		</method>
		<method name="set_anchors_preset">
			<return type="void" />
			<argument index="0" name="preset" type="int" enum="Control.LayoutPreset" />
			<argument index="1" name="keep_margins" type="bool" default="false" />
			<description>
				Устанавливает якоря на [code]предустановку[/code] из перечня [enum Control.LayoutPreset]. Это код, эквивалентный использованию меню Layout в 2D-редакторе.
				Если [code]keep_margins[/code] имеет значение [code]true[/code], положение контрола также будет обновлено.
			</description>
		</method>
		<method name="set_begin">
			<return type="void" />
			<argument index="0" name="position" type="Vector2" />
			<description>
				Устанавливает [member margin_left] и [member margin_top] одновременно. Эквивалентно изменению [member rect_position].
			</description>
		</method>
		<method name="set_drag_forwarding">
			<return type="void" />
			<argument index="0" name="target" type="Control" />
			<description>
				Перенаправляет обработку перетаскивания этого элемента управления на [code]target[/code] элемент управления.
				Переадресация может быть реализована в целевом элементе управления аналогично методам [method get_drag_data], [method can_drop_data] и [method drop_data], но с двумя отличиями:
				1. Имя функции должно иметь суффикс [b]_fw[/b].
				2. Функция должна принимать дополнительный аргумент, которым является элемент управления, выполняющий пересылку
				[codeblock]
				# ThisControl.gd
				extends Control
				func _ready():
				    set_drag_forwarding(target_control)

				# TargetControl.gd
				extends Control
				func can_drop_data_fw(position, data, from_control):
				    return true

				func drop_data_fw(position, data, from_control):
				    my_handle_data(data)

				func get_drag_data_fw(position, from_control):
				    set_drag_preview(my_preview)
				    return my_data()
				[/codeblock]
			</description>
		</method>
		<method name="set_drag_preview">
			<return type="void" />
			<argument index="0" name="control" type="Control" />
			<description>
				Показывает заданный элемент управления на указателе мыши. Хорошее время для вызова этого метода - [метод get_drag_data]. Элемент управления не должен находиться в дереве сцены. Не следует освобождать элемент управления и хранить ссылку на него дольше, чем длится перетаскивание. Она будет удалена автоматически после завершения перетаскивания.
				[codeblock]
				export (Color, RGBA) var color = Color(1, 0, 0, 1)

				func get_drag_data(position):
				    # Используйте элемент управления, которого нет в дереве
				    var cpb = ColorPickerButton.new()
				    cpb.color = color
				    cpb.rect_size = Vector2(50, 50)
				    set_drag_preview(cpb)
				    return color
				[/codeblock]
			</description>
		</method>
		<method name="set_end">
			<return type="void" />
			<argument index="0" name="position" type="Vector2" />
			<description>
				Одновременно устанавливает [member margin_right] и [member margin_bottom].
			</description>
		</method>
		<method name="set_focus_neighbour">
			<return type="void" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<argument index="1" name="neighbour" type="NodePath" />
			<description>
				Устанавливает якорь, идентифицированный константой [code]margin[/code] из перечисления [enum Margin] в [Control] на пути [code]neighbor[/code] узла. Метод-установщик для [member focus_neighbour_bottom], [member focus_neighbour_left], [member focus_neighbour_right] и [member focus_neighbour_top].
			</description>
		</method>
		<method name="set_global_position">
			<return type="void" />
			<argument index="0" name="position" type="Vector2" />
			<argument index="1" name="keep_margins" type="bool" default="false" />
			<description>
				Устанавливает [член rect_global_position] на заданную [code]позицию[/code].
				Если [code]keep_margins[/code] имеет значение [code]true[/code], то вместо полей будут обновлены якоря элемента управления.
			</description>
		</method>
		<method name="set_margin">
			<return type="void" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<argument index="1" name="offset" type="float" />
			<description>
				Устанавливает поле, определяемое константой [code]margin[/code] из перечисления [enum Margin], на заданное [code]смещение[/code]. Метод-установщик для [member margin_bottom], [member margin_left], [member margin_right] и [member margin_top].
			</description>
		</method>
		<method name="set_margins_preset">
			<return type="void" />
			<argument index="0" name="preset" type="int" enum="Control.LayoutPreset" />
			<argument index="1" name="resize_mode" type="int" enum="Control.LayoutPresetMode" default="0" />
			<argument index="2" name="margin" type="int" default="0" />
			<description>
				Устанавливает поля на [code]предустановку[/code] из перечня [enum Control.LayoutPreset]. Это код, эквивалентный использованию меню Layout в 2D-редакторе.
				Используйте параметр [code]resize_mode[/code] с константами из [enum Control.LayoutPresetMode], чтобы лучше определить результирующий размер [Control]. Постоянный размер будет игнорироваться, если используется с пресетами, изменяющими размер, например [code]PRESET_LEFT_WIDE[/code].
				Используйте параметр [code]margin[/code] для определения зазора между [Control] и краями.
			</description>
		</method>
		<method name="set_position">
			<return type="void" />
			<argument index="0" name="position" type="Vector2" />
			<argument index="1" name="keep_margins" type="bool" default="false" />
			<description>
				Устанавливает [член rect_position] в заданную [code]позицию[/code].
				Если [code]keep_margins[/code] имеет значение [code]true[/code], то вместо полей будут обновлены якоря элемента управления.
			</description>
		</method>
		<method name="set_rotation">
			<return type="void" />
			<argument index="0" name="radians" type="float" />
			<description>
				Устанавливает вращение (в радианах).
			</description>
		</method>
		<method name="set_size">
			<return type="void" />
			<argument index="0" name="size" type="Vector2" />
			<argument index="1" name="keep_margins" type="bool" default="false" />
			<description>
				Устанавливает размер (см. [member rect_size]).
				Если [code]keep_margins[/code] имеет значение [code]true[/code], то вместо полей будут обновляться якоря элемента управления.
			</description>
		</method>
		<method name="show_modal">
			<return type="void" />
			<argument index="0" name="exclusive" type="bool" default="false" />
			<description>
				Отображает элемент управления как модальный. Элемент управления должен быть вложенным окном. Модальные элементы управления фиксируют входные сигналы до тех пор, пока не будут закрыты или пока не будет получен доступ к области за их пределами. Когда модальный элемент управления теряет фокус или нажимается клавиша ESC, он автоматически скрывается. Модальные элементы управления широко используются для всплывающих диалогов и меню.
				Если [code]exclusive[/code] имеет значение [code]true[/code], другие элементы управления не будут получать входные данные, а щелчок за пределами этого элемента управления не приведет к его закрытию.
			</description>
		</method>
		<method name="warp_mouse">
			<return type="void" />
			<argument index="0" name="to_position" type="Vector2" />
			<description>
				Перемещает курсор мыши в [code]to_position[/code], относительно [member rect_position] данного [Control].
			</description>
		</method>
	</methods>
	<members>
		<member name="anchor_bottom" type="float" setter="_set_anchor" getter="get_anchor" default="0.0">
			Привязывает нижний край узла к началу, центру или концу его родительского элемента управления. От этого зависит, как обновляется нижняя граница при перемещении или изменении размера узла. Для удобства можно использовать одну из констант [enum Anchor].
		</member>
		<member name="anchor_left" type="float" setter="_set_anchor" getter="get_anchor" default="0.0">
			Привязывает левый край узла к началу, центру или концу его родительского элемента управления. От этого зависит, как обновляется левая граница при перемещении или изменении размера узла. Для удобства можно использовать одну из констант [enum Anchor].
		</member>
		<member name="anchor_right" type="float" setter="_set_anchor" getter="get_anchor" default="0.0">
			Привязывает правый край узла к началу, центру или концу его родительского элемента управления. От этого зависит, как обновляется правый край при перемещении или изменении размера узла. Для удобства можно использовать одну из констант [enum Anchor].
		</member>
		<member name="anchor_top" type="float" setter="_set_anchor" getter="get_anchor" default="0.0">
			Привязывает верхний край узла к началу, центру или концу его родительского элемента управления. От этого зависит, как обновляется верхняя граница при перемещении или изменении размера узла. Для удобства можно использовать одну из констант [enum Anchor].
		</member>
		<member name="focus_mode" type="int" setter="set_focus_mode" getter="get_focus_mode" enum="Control.FocusMode" default="0">
			Режим доступа к фокусу для элемента управления (None, Click или All). Одновременно в фокусе может находиться только один элемент управления, и он будет принимать сигналы клавиатуры.
		</member>
		<member name="focus_neighbour_bottom" type="NodePath" setter="set_focus_neighbour" getter="get_focus_neighbour" default="NodePath(&quot;&quot;)">
			Указывает Godot, какому узлу он должен передать фокус клавиатуры, если пользователь нажмет стрелку вниз на клавиатуре или вниз на геймпаде по умолчанию. Вы можете изменить клавишу, отредактировав действие ввода [code]ui_down[/code]. Узел должен быть [Control]. Если это свойство не задано, Godot передаст фокус ближайшему [Control], расположенному снизу от этого.
		</member>
		<member name="focus_neighbour_left" type="NodePath" setter="set_focus_neighbour" getter="get_focus_neighbour" default="NodePath(&quot;&quot;)">
			Указывает Godot, какому узлу он должен передать фокус клавиатуры, если пользователь по умолчанию нажимает стрелку влево на клавиатуре или влево на геймпаде. Вы можете изменить клавишу, отредактировав действие ввода [code]ui_left[/code]. Узел должен быть [Control]. Если это свойство не задано, Godot передаст фокус ближайшему [Control] слева от этого.
		</member>
		<member name="focus_neighbour_right" type="NodePath" setter="set_focus_neighbour" getter="get_focus_neighbour" default="NodePath(&quot;&quot;)">
			Указывает Godot, какому узлу он должен передать фокус клавиатуры, если пользователь нажмет стрелку вправо на клавиатуре или вправо на геймпаде по умолчанию. Вы можете изменить клавишу, отредактировав действие ввода [code]ui_right[/code]. Узел должен быть [Control]. Если это свойство не задано, Godot передаст фокус ближайшему [Control], расположенному снизу от этого.
		</member>
		<member name="focus_neighbour_top" type="NodePath" setter="set_focus_neighbour" getter="get_focus_neighbour" default="NodePath(&quot;&quot;)">
			Указывает Godot, какому узлу он должен передать фокус клавиатуры, если пользователь нажмет стрелку top на клавиатуре или top на геймпаде по умолчанию. Вы можете изменить клавишу, отредактировав действие ввода [code]ui_top[/code]. Узел должен быть [Control]. Если это свойство не задано, Godot передаст фокус ближайшему [Control], расположенному снизу от этого узла.
		</member>
		<member name="focus_next" type="NodePath" setter="set_focus_next" getter="get_focus_next" default="NodePath(&quot;&quot;)">
			Указывает Godot, какому узлу он должен передать фокус клавиатуры, если пользователь по умолчанию нажимает Tab на клавиатуре. Вы можете изменить клавишу, отредактировав входное действие [code]ui_focus_next[/code].
			Если это свойство не задано, Godot выберет "наилучшее предположение" на основе окружающих узлов в дереве сцены.
		</member>
		<member name="focus_previous" type="NodePath" setter="set_focus_previous" getter="get_focus_previous" default="NodePath(&quot;&quot;)">
			Указывает Godot, какому узлу он должен передать фокус клавиатуры, если пользователь по умолчанию нажимает Shift+Tab на клавиатуре. Вы можете изменить клавишу, отредактировав входное действие [code]ui_focus_prev[/code].
			Если это свойство не задано, Godot будет выбирать "лучшее предположение" на основе окружающих узлов в дереве сцены.
		</member>
		<member name="grow_horizontal" type="int" setter="set_h_grow_direction" getter="get_h_grow_direction" enum="Control.GrowDirection" default="1">
			Управляет направлением горизонтальной оси, в котором должен расти элемент управления, если его минимальный размер по горизонтали изменяется на больший, чем текущий, так как элемент всегда должен быть не меньше минимального размера.
		</member>
		<member name="grow_vertical" type="int" setter="set_v_grow_direction" getter="get_v_grow_direction" enum="Control.GrowDirection" default="1">
			Управляет направлением вертикальной оси, в котором должен расти элемент управления, если его минимальный размер по вертикали изменяется на больший, чем текущий, так как элемент всегда должен быть не меньше минимального размера.
		</member>
		<member name="hint_tooltip" type="String" setter="set_tooltip" getter="_get_tooltip" default="&quot;&quot;">
			Изменяет текст всплывающей подсказки. Подсказка появляется, когда курсор мыши пользователя остается незадействованным над этим элементом управления в течение нескольких мгновений, при условии, что свойство [member mouse_filter] не является [constant MOUSE_FILTER_IGNORE]. Вы можете изменить время появления всплывающей подсказки с помощью опции [code]gui/timers/tooltip_delay_sec[/code] в Настройках проекта.
			Всплывающая подсказка будет использовать либо реализацию по умолчанию, либо пользовательскую, которую вы можете создать, переопределив [метод _make_custom_tooltip]. Всплывающая подсказка по умолчанию включает в себя [PopupPanel] и [Label], свойства темы которых могут быть настроены с помощью методов [Theme] с [code]"TooltipPanel"[/code] и [code]"TooltipLabel"[/code] соответственно. Например:
			[codeblock]
			var style_box = StyleBoxFlat.new()
			style_box.set_bg_color(Color(1, 1, 0))
			style_box.set_border_width_all(2)
			# Здесь мы предполагаем, что свойству `theme` заранее назначена пользовательская тема.
			theme.set_stylebox("panel", "TooltipPanel", style_box)
			theme.set_color("font_color", "TooltipLabel", Color(0, 1, 1))
			[/codeblock]
		</member>
		<member name="input_pass_on_modal_close_click" type="bool" setter="set_pass_on_modal_close_click" getter="get_pass_on_modal_close_click" default="true">
			Включает, должен ли вход распространяться при закрытии элемента управления как модального.
			Если [code]false[/code], прекращается обработка событий ввода на вьюпорте. Сначала область просмотра скрывает модальный элемент, а затем отмечает вход как обработанный.
		</member>
		<member name="margin_bottom" type="float" setter="set_margin" getter="get_margin" default="0.0">
			Расстояние между нижним краем узла и его родительским элементом управления, основанное на [member anchor_bottom].
			Отступы часто контролируются одним или несколькими родительскими узлами [Container], поэтому не следует изменять их вручную, если ваш узел является прямым дочерним узлом [Container]. Отступы обновляются автоматически при перемещении или изменении размера узла.
		</member>
		<member name="margin_left" type="float" setter="set_margin" getter="get_margin" default="0.0">
			Расстояние между левым краем узла и его родительским элементом управления, основанное на [member anchor_left].
			Отступы часто контролируются одним или несколькими родительскими узлами [Container], поэтому не следует изменять их вручную, если ваш узел является прямым дочерним узлом [Container]. Отступы обновляются автоматически при перемещении или изменении размера узла.
		</member>
		<member name="margin_right" type="float" setter="set_margin" getter="get_margin" default="0.0">
			Расстояние между правым краем узла и его родительским элементом управления, основанное на [member anchor_right].
			Отступы часто контролируются одним или несколькими родительскими узлами [Container], поэтому не следует изменять их вручную, если ваш узел является прямым дочерним узлом [Container]. Отступы обновляются автоматически при перемещении или изменении размера узла.
		</member>
		<member name="margin_top" type="float" setter="set_margin" getter="get_margin" default="0.0">
			Расстояние между верхним краем узла и его родительским элементом управления, основанное на [member anchor_top].
			Отступы часто контролируются одним или несколькими родительскими узлами [Container], поэтому не следует изменять их вручную, если ваш узел является прямым дочерним узлом [Container]. Отступы обновляются автоматически при перемещении или изменении размера узла.
		</member>
		<member name="mouse_default_cursor_shape" type="int" setter="set_default_cursor_shape" getter="get_default_cursor_shape" enum="Control.CursorShape" default="0">
			Форма курсора по умолчанию для этого элемента управления. Пригодится для плагинов Godot и приложений или игр, использующих курсоры мыши в системе.
			[b]Примечание:[/b] В Linux форма курсора может отличаться в зависимости от темы курсора в системе.
		</member>
		<member name="mouse_filter" type="int" setter="set_mouse_filter" getter="get_mouse_filter" enum="Control.MouseFilter" default="0">
			Определяет, будет ли элемент управления получать события ввода кнопок мыши через [метод _gui_input] и как эти события должны обрабатываться. Также управляет тем, может ли элемент управления принимать сигналы [signal mouse_entered] и [signal mouse_exited]. Чтобы узнать, что делает каждая из констант, смотрите константы.
		</member>
		<member name="rect_clip_content" type="bool" setter="set_clip_contents" getter="is_clipping_contents" default="false">
			Разрешает, чтобы рендеринг дочерних элементов [CanvasItem] был обрезан до прямоугольника этого элемента управления. Если [code]true[/code], то части дочернего элемента, которые будут находиться за пределами прямоугольника этого элемента управления, не будут отрисовываться.
		</member>
		<member name="rect_global_position" type="Vector2" setter="_set_global_position" getter="get_global_position">
			Глобальная позиция узла относительно мира (обычно в левом верхнем углу окна).
		</member>
		<member name="rect_min_size" type="Vector2" setter="set_custom_minimum_size" getter="get_custom_minimum_size" default="Vector2( 0, 0 )">
			Минимальный размер ограничивающего прямоугольника узла. Если вы зададите значение больше (0, 0), то ограничивающий прямоугольник узла всегда будет иметь как минимум этот размер, даже если его содержимое меньше. Если установить значение (0, 0), узел будет автоматически подгонять размеры под свое содержимое, будь то текстура или дочерние узлы.
		</member>
		<member name="rect_pivot_offset" type="Vector2" setter="set_pivot_offset" getter="get_pivot_offset" default="Vector2( 0, 0 )">
			По умолчанию шарниром узла является его левый верхний угол. Когда вы изменяете [member rect_rotation] или [member rect_scale], он будет вращаться или масштабироваться вокруг этой точки опоры. Установите это свойство на [member rect_size] / 2, чтобы поворачивать узел вокруг центра элемента управления.
		</member>
		<member name="rect_position" type="Vector2" setter="_set_position" getter="get_position" default="Vector2( 0, 0 )">
			Положение узла относительно его родителя. Она соответствует левому верхнему углу прямоугольника. На это свойство не влияет [member rect_pivot_offset].
		</member>
		<member name="rect_rotation" type="float" setter="set_rotation_degrees" getter="get_rotation_degrees" default="0.0">
			Поворот узла вокруг точки вращения, в градусах. Для изменения положения шарнира смотрите [member rect_pivot_offset].
		</member>
		<member name="rect_scale" type="Vector2" setter="set_scale" getter="get_scale" default="Vector2( 1, 1 )">
			Масштаб узла относительно его [member rect_size]. Измените это свойство, чтобы масштабировать узел вокруг его [член rect_pivot_offset]. В соответствии с этим значением будет масштабироваться и [член hint_tooltip] элемента управления.
			[b]Примечание:[/b] Это свойство в основном предназначено для использования в целях анимации. Текст внутри элемента управления будет выглядеть пикселизированным или размытым при масштабировании элемента управления. Для поддержки нескольких разрешений в вашем проекте используйте соответствующий режим растяжения области просмотра, как описано в [url=$DOCS_URL/tutorials/rendering/multiple_resolutions.html]документации[/url], вместо того чтобы масштабировать Controls по отдельности.
			[b]Примечание:[/b] Если узел Control является дочерним узлом узла [Container], то при инстанцировании сцены масштаб будет сброшен на [code]Vector2(1, 1)[/code]. Чтобы установить масштаб Control при инстансе, подождите один кадр, используя [code]yield(get_tree(), "idle_frame")[/code], а затем установите его свойство [member rect_scale].
		</member>
		<member name="rect_size" type="Vector2" setter="_set_size" getter="get_size" default="Vector2( 0, 0 )">
			Размер ограничивающего прямоугольника узла, в пикселях. Узлы [Container] обновляют это свойство автоматически.
		</member>
		<member name="size_flags_horizontal" type="int" setter="set_h_size_flags" getter="get_h_size_flags" default="1">
			Сообщает родительским узлам [Container], как они должны изменить размер и разместить узел по оси X. Для изменения флагов используйте одну из констант [enum SizeFlags]. Ознакомьтесь с константами, чтобы узнать, что каждая из них делает.
		</member>
		<member name="size_flags_stretch_ratio" type="float" setter="set_stretch_ratio" getter="get_stretch_ratio" default="1.0">
			Если узел и хотя бы один из его соседей используют флаг размера [constant SIZE_EXPAND], родительский [Container] позволит ему занять больше или меньше места в зависимости от этого свойства. Если этот узел имеет коэффициент растяжения 2, а его сосед - коэффициент 1, то этот узел займет две трети доступного пространства.
		</member>
		<member name="size_flags_vertical" type="int" setter="set_v_size_flags" getter="get_v_size_flags" default="1">
			Сообщает родительским узлам [Container], как они должны изменить размер и разместить узел по оси Y. Для изменения флагов используйте одну из констант [enum SizeFlags]. Ознакомьтесь с константами, чтобы узнать, что каждая из них делает.
		</member>
		<member name="theme" type="Theme" setter="set_theme" getter="get_theme">
			Изменение этого свойства заменяет текущий ресурс [Theme], используемый этим узлом и всеми его дочерними узлами [Control].
		</member>
		<member name="theme_type_variation" type="String" setter="set_theme_type_variation" getter="get_theme_type_variation" default="&quot;&quot;">
			Имя вариации типа темы, используемой данным элементом [Control] для поиска собственных элементов темы. Если свойство пустое, используется имя класса узла (например, [code]Button[/code] для элемента управления [Button]), а также имена классов всех родительских классов (в порядке наследования).
			Когда это свойство установлено, оно дает наивысший приоритет типу с указанным именем. Этот тип, в свою очередь, может расширять другой тип, образуя цепочку зависимостей. Смотрите [метод Theme.set_type_variation]. Если элемент темы не может быть найден с помощью этого типа или его базовых типов, поиск возвращается к именам классов.
			[b]Примечание:[/b] Для поиска собственных элементов [Control] используйте различные методы [code]get_*[/code], не указывая [code]theme_type[/code].
			[b]Примечание:[/b] Элементы темы ищутся в порядке дерева, от ветви к корню, где каждый узел [Control] проверяется на наличие свойства [member theme]. Возвращается самое раннее совпадение с именем любого типа/класса. Тема уровня проекта и тема по умолчанию проверяются в последнюю очередь.
		</member>
	</members>
	<signals>
		<signal name="focus_entered">
			<description>
				Выдается, когда узел получает фокус клавиатуры.
			</description>
		</signal>
		<signal name="focus_exited">
			<description>
				Выдается, когда узел теряет фокус клавиатуры.
			</description>
		</signal>
		<signal name="gui_input">
			<argument index="0" name="event" type="InputEvent" />
			<description>
				Выдается, когда узел получает событие [InputEvent].
			</description>
		</signal>
		<signal name="minimum_size_changed">
			<description>
				Выдается при изменении минимального размера узла.
			</description>
		</signal>
		<signal name="modal_closed">
			<description>
				Выдается при закрытии модального элемента [Control]. См. [метод show_modal].
			</description>
		</signal>
		<signal name="mouse_entered">
			<description>
				Выдается, когда мышь попадает в область [code]Rect[/code] элемента управления, если его [member mouse_filter] позволяет событию достичь его.
				[b]Примечание:[/b] [сигнал mouse_entered] не будет выдан, если мышь попадает в дочерний узел [Control] до того, как попадет в область [code]Rect[/code] родительского элемента управления, по крайней мере до тех пор, пока мышь не будет перемещена, чтобы достичь области [code]Rect[/code] родительского элемента управления.
			</description>
		</signal>
		<signal name="mouse_exited">
			<description>
				Выдается, когда мышь покидает область [code]Rect[/code] элемента управления, если его [member mouse_filter] позволяет событию достичь ее.
				[b]Примечание:[/b] [сигнал mouse_exited] будет выдан, если мышь войдет в дочерний узел [Control], даже если курсор мыши все еще находится внутри области [code]Rect[/code] родительского элемента.
				Если вы хотите проверить, действительно ли мышь покинула область, игнорируя все верхние узлы, вы можете использовать код, подобный этому:
				[codeblock]
				func _on_mouse_exited():
				    if not Rect2(Vector2(), rect_size).has_point(get_local_mouse_position()):
				        # Не парит над территорией.
				[/codeblock]
			</description>
		</signal>
		<signal name="resized">
			<description>
				Выдается при изменении размера элемента управления.
			</description>
		</signal>
		<signal name="size_flags_changed">
			<description>
				Выдается при изменении одного из флагов размера. См. [member size_flags_horizontal] и [member size_flags_vertical].
			</description>
		</signal>
	</signals>
	<constants>
		<constant name="FOCUS_NONE" value="0" enum="FocusMode">
			Узел не может захватить фокус. Используется с [member focus_mode].
		</constant>
		<constant name="FOCUS_CLICK" value="1" enum="FocusMode">
			Узел может захватить фокус только при щелчке мыши. Используется с [member focus_mode].
		</constant>
		<constant name="FOCUS_ALL" value="2" enum="FocusMode">
			Узел может захватить фокус по щелчку мыши или с помощью стрелок и клавиш Tab на клавиатуре. Используется с [member focus_mode].
		</constant>
		<constant name="NOTIFICATION_RESIZED" value="40">
			Отправляется при изменении размера узла. Используйте [member rect_size], чтобы получить новый размер.
		</constant>
		<constant name="NOTIFICATION_MOUSE_ENTER" value="41">
			Отправляется, когда указатель мыши попадает в узел.
		</constant>
		<constant name="NOTIFICATION_MOUSE_EXIT" value="42">
			Отправляется, когда указатель мыши выходит из узла.
		</constant>
		<constant name="NOTIFICATION_FOCUS_ENTER" value="43">
			Отправляется, когда узел захватывает фокус.
		</constant>
		<constant name="NOTIFICATION_FOCUS_EXIT" value="44">
			Отправляется, когда узел теряет фокус.
		</constant>
		<constant name="NOTIFICATION_THEME_CHANGED" value="45">
			Отправляется при изменении [member theme] узла, непосредственно перед тем, как Godot перерисовывает элемент управления. Происходит при вызове одного из методов [code]add_*_override[/code].
		</constant>
		<constant name="NOTIFICATION_MODAL_CLOSE" value="46">
			Отправляется при закрытии открытого модального диалога. См. раздел [метод show_modal].
		</constant>
		<constant name="NOTIFICATION_SCROLL_BEGIN" value="47">
			Отправляется, когда этот узел находится внутри [ScrollContainer], который начал прокручиваться.
		</constant>
		<constant name="NOTIFICATION_SCROLL_END" value="48">
			Отправляется, когда этот узел находится внутри [ScrollContainer], который перестал прокручиваться.
		</constant>
		<constant name="CURSOR_ARROW" value="0" enum="CursorShape">
			Показывает системный курсор мыши со стрелкой, когда пользователь наводит курсор на узел. Используется с [member mouse_default_cursor_shape].
		</constant>
		<constant name="CURSOR_IBEAM" value="1" enum="CursorShape">
			Показывает двутавровый курсор мыши системы, когда пользователь наводит курсор на узел. I-образный указатель имеет форму, похожую на букву "I". Он указывает пользователю, что он может выделить или вставить текст.
		</constant>
		<constant name="CURSOR_POINTING_HAND" value="2" enum="CursorShape">
			Показывает курсор мыши системы, когда пользователь наводит курсор на узел.
		</constant>
		<constant name="CURSOR_CROSS" value="3" enum="CursorShape">
			Показывает крестообразный курсор мыши системы, когда пользователь наводит курсор на узел.
		</constant>
		<constant name="CURSOR_WAIT" value="4" enum="CursorShape">
			Показывает ожидающий курсор мыши системы, когда пользователь наводит курсор на узел. Часто это песочные часы.
		</constant>
		<constant name="CURSOR_BUSY" value="5" enum="CursorShape">
			Показывает занятый системой курсор мыши, когда пользователь наводит курсор на узел. Часто это стрелка с маленькими песочными часами.
		</constant>
		<constant name="CURSOR_DRAG" value="6" enum="CursorShape">
			Показывайте системный курсор мыши, часто в виде закрытого кулака или символа креста, когда пользователь наводит курсор на узел. Это говорит пользователю о том, что в данный момент он перетаскивает элемент, например узел в доке сцены.
		</constant>
		<constant name="CURSOR_CAN_DROP" value="7" enum="CursorShape">
			Показывайте падающий курсор мыши системы, когда пользователь наводит курсор на узел. Это может быть открытая рука. Это говорит пользователю, что он может бросить элемент, который он в данный момент захватывает, например узел в доке сцены.
		</constant>
		<constant name="CURSOR_FORBIDDEN" value="8" enum="CursorShape">
			Показывает запрещенный системой курсор мыши, когда пользователь наводит курсор на узел. Часто это перечеркнутый круг.
		</constant>
		<constant name="CURSOR_VSIZE" value="9" enum="CursorShape">
			Показывает вертикальный курсор мыши системы для изменения размера, когда пользователь наводит курсор на узел. Двуглавая вертикальная стрелка. Она указывает пользователю, что он может изменить размер окна или панели по вертикали.
		</constant>
		<constant name="CURSOR_HSIZE" value="10" enum="CursorShape">
			Показывает горизонтальный курсор мыши системы для изменения размера, когда пользователь наводит курсор на узел. Двуглавая горизонтальная стрелка. Она указывает пользователю, что он может изменить размер окна или панели по горизонтали.
		</constant>
		<constant name="CURSOR_BDIAGSIZE" value="11" enum="CursorShape">
			Показывает курсор мыши для изменения размера окна системы, когда пользователь наводит курсор на узел. Курсор представляет собой двунаправленную стрелку, идущую от левого нижнего угла к правому верхнему. Она сообщает пользователю, что он может изменять размеры окна или панели как по горизонтали, так и по вертикали.
		</constant>
		<constant name="CURSOR_FDIAGSIZE" value="12" enum="CursorShape">
			Показывать курсор мыши для изменения размера окна системы, когда пользователь наводит курсор на узел. Курсор представляет собой двунаправленную стрелку, идущую от левого верхнего края к правому нижнему, противоположную [constant CURSOR_BDIAGSIZE]. Она сообщает пользователю, что он может изменять размеры окна или панели как по горизонтали, так и по вертикали.
		</constant>
		<constant name="CURSOR_MOVE" value="13" enum="CursorShape">
			Показывает перемещение курсора мыши системы, когда пользователь наводит курсор на узел. Показывает 2 двуглавые стрелки под углом 90 градусов. Это говорит пользователю о том, что он может свободно перемещать элемент пользовательского интерфейса.
		</constant>
		<constant name="CURSOR_VSPLIT" value="14" enum="CursorShape">
			Показывает вертикальное разделение курсора мыши в системе, когда пользователь наводит курсор на узел. В Windows это то же самое, что и [constant CURSOR_VSIZE].
		</constant>
		<constant name="CURSOR_HSPLIT" value="15" enum="CursorShape">
			Показывает системное горизонтальное разделение курсора мыши, когда пользователь наводит курсор на узел. В Windows это то же самое, что и [constant CURSOR_HSIZE].
		</constant>
		<constant name="CURSOR_HELP" value="16" enum="CursorShape">
			Показывает курсор мыши системы помощи, когда пользователь наводит курсор на узел, в виде вопросительного знака.
		</constant>
		<constant name="PRESET_TOP_LEFT" value="0" enum="LayoutPreset">
			Привязывает все 4 якоря к левому верхнему углу границ родительского элемента управления. Используется с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_TOP_RIGHT" value="1" enum="LayoutPreset">
			Привязывает все 4 якоря к верхнему правому краю границ родительского элемента управления. Используется с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_BOTTOM_LEFT" value="2" enum="LayoutPreset">
			Привязывает все 4 якоря к левому нижнему краю границ родительского элемента управления. Используется с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_BOTTOM_RIGHT" value="3" enum="LayoutPreset">
			Привязывает все 4 якоря к правому нижнему краю границ родительского элемента управления. Используется с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_CENTER_LEFT" value="4" enum="LayoutPreset">
			Привязывает все 4 якоря к центру левого края границ родительского элемента управления. Используется с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_CENTER_TOP" value="5" enum="LayoutPreset">
			Привязывает все 4 якоря к центру верхнего края границ родительского элемента управления. Используется с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_CENTER_RIGHT" value="6" enum="LayoutPreset">
			Привязывает все 4 якоря к центру правого края границ родительского элемента управления. Используется с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_CENTER_BOTTOM" value="7" enum="LayoutPreset">
			Привязывает все 4 якоря к центру нижнего края границ родительского элемента управления. Используется с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_CENTER" value="8" enum="LayoutPreset">
			Привязывает все 4 якоря к центру границ родительского элемента управления. Используется с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_LEFT_WIDE" value="9" enum="LayoutPreset">
			Привяжите все 4 якоря к левому краю родительского элемента управления. Левое поле становится относительным к левому краю, а верхнее поле - к левому верхнему углу родительского узла. Используйте с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_TOP_WIDE" value="10" enum="LayoutPreset">
			Привяжите все 4 якоря к верхнему краю родительского элемента управления. Левое поле становится относительно левого верхнего угла, верхнее поле - относительно верхнего края, а правое поле - относительно правого верхнего угла родительского узла. Используйте с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_RIGHT_WIDE" value="11" enum="LayoutPreset">
			Привяжите все 4 якоря к правому краю родительского элемента управления. Правое поле становится относительным к правому краю, а верхнее поле - к правому верхнему углу родительского узла. Используйте с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_BOTTOM_WIDE" value="12" enum="LayoutPreset">
			Привяжите все 4 якоря к нижнему краю родительского элемента управления. Левое поле становится относительно левого нижнего угла, нижнее поле - относительно нижнего края, а правое поле - относительно правого нижнего угла родительского узла. Используйте с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_VCENTER_WIDE" value="13" enum="LayoutPreset">
			Привяжите все 4 якоря к вертикальной линии, которая разрезает родительский элемент управления пополам. Используйте с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_HCENTER_WIDE" value="14" enum="LayoutPreset">
			Привяжите все 4 якоря к горизонтальной линии, которая разрезает родительский элемент управления пополам. Используйте с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_WIDE" value="15" enum="LayoutPreset">
			Привяжите все 4 якоря к соответствующим углам родительского элемента управления. Установите все 4 поля на 0 после применения этой предустановки, и [Control] будет соответствовать своему родительскому элементу управления. Это эквивалентно опции макета "Полный прямоугольник" в редакторе. Используйте с [методом set_anchors_preset].
		</constant>
		<constant name="PRESET_MODE_MINSIZE" value="0" enum="LayoutPresetMode">
			Размер элемента управления будет изменен до минимального.
		</constant>
		<constant name="PRESET_MODE_KEEP_WIDTH" value="1" enum="LayoutPresetMode">
			Ширина элемента управления не изменится.
		</constant>
		<constant name="PRESET_MODE_KEEP_HEIGHT" value="2" enum="LayoutPresetMode">
			Высота элемента управления не изменится.
		</constant>
		<constant name="PRESET_MODE_KEEP_SIZE" value="3" enum="LayoutPresetMode">
			Размер элемента управления не изменится.
		</constant>
		<constant name="SIZE_FILL" value="1" enum="SizeFlags">
			Приказывает родительскому узлу [Container] расширить границы этого узла, чтобы заполнить все доступное пространство, не вытесняя другие узлы. Используется с [member size_flags_horizontal] и [member size_flags_vertical].
		</constant>
		<constant name="SIZE_EXPAND" value="2" enum="SizeFlags">
			Сообщает родительскому узлу [Container], чтобы этот узел занял все свободное пространство на указанной вами оси. Если несколько соседних узлов настроены на расширение, они разделят пространство в соответствии с их коэффициентом растяжения. Смотрите [член size_flags_stretch_ratio]. Используется вместе с [member size_flags_horizontal] и [member size_flags_vertical].
		</constant>
		<constant name="SIZE_EXPAND_FILL" value="3" enum="SizeFlags">
			Устанавливает флаги размера узла для заполнения и расширения. Дополнительную информацию см. в 2 константах выше.
		</constant>
		<constant name="SIZE_SHRINK_CENTER" value="4" enum="SizeFlags">
			Указывает родительскому элементу [Container] центрировать узел в себе. Он центрирует элемент управления на основе его ограничительной рамки, поэтому не работает с флагами заполнения или расширения размера. Используется с [member size_flags_horizontal] и [member size_flags_vertical].
		</constant>
		<constant name="SIZE_SHRINK_END" value="8" enum="SizeFlags">
			Указывает родительскому [Container] выровнять узел по его концу, либо по нижнему, либо по правому краю. Не работает с флагами заполнения или расширения размера. Используйте с [member size_flags_horizontal] и [member size_flags_vertical].
		</constant>
		<constant name="MOUSE_FILTER_STOP" value="0" enum="MouseFilter">
			При нажатии на кнопку мыши элемент управления будет получать события ввода через [метод _gui_input]. Также элемент управления будет получать сигналы [signal mouse_entered] и [signal mouse_exited]. Эти события автоматически помечаются как обработанные, и они не будут распространяться дальше на другие элементы управления. Это также приводит к блокировке сигналов в других элементах управления.
		</constant>
		<constant name="MOUSE_FILTER_PASS" value="1" enum="MouseFilter">
			При нажатии на кнопку мыши элемент управления будет получать события ввода через [метод _gui_input]. Также элемент управления будет получать сигналы [signal mouse_entered] и [signal mouse_exited]. Если этот элемент управления не обработает событие, будет рассмотрен родительский элемент управления (если таковой имеется), и так далее, пока не останется родительского элемента управления, который потенциально мог бы его обработать. Это также позволяет подавать сигналы в другие элементы управления. Даже если ни один элемент управления не обработал событие, оно все равно будет обработано автоматически, так что необработанный ввод не произойдет.
		</constant>
		<constant name="MOUSE_FILTER_IGNORE" value="2" enum="MouseFilter">
			Элемент управления не будет получать события ввода кнопок мыши через [метод _gui_input]. Элемент управления также не будет получать сигналы [signal mouse_entered] и [signal mouse_exited]. Это не блокирует получение этих событий другими элементами управления или подачу сигналов. Игнорируемые события не будут обрабатываться автоматически.
		</constant>
		<constant name="GROW_DIRECTION_BEGIN" value="0" enum="GrowDirection">
			Элемент управления будет расти влево или вверх, если его минимальный размер по соответствующей оси будет больше текущего.
		</constant>
		<constant name="GROW_DIRECTION_END" value="1" enum="GrowDirection">
			Элемент управления будет расти вправо или вниз, если его минимальный размер на соответствующей оси будет больше текущего.
		</constant>
		<constant name="GROW_DIRECTION_BOTH" value="2" enum="GrowDirection">
			Элемент управления будет расти в обоих направлениях одинаково, чтобы компенсировать, если его минимальный размер изменится на больший, чем текущий.
		</constant>
		<constant name="ANCHOR_BEGIN" value="0" enum="Anchor">
			Привязывает одну из 4 сторон якоря к началу [code]Rect[/code] узла, в левом верхнем углу. Используйте его с одной из переменных-членов [code]anchor_*[/code], например [member anchor_left]. Чтобы изменить все 4 якоря сразу, используйте [метод set_anchors_preset].
		</constant>
		<constant name="ANCHOR_END" value="1" enum="Anchor">
			Привязывает одну из 4 сторон якоря к концу [code]Rect[/code] узла в правом нижнем углу. Используйте его с одной из переменных-членов [code]anchor_*[/code], например [member anchor_left]. Чтобы изменить все 4 якоря сразу, используйте [метод set_anchors_preset].
		</constant>
	</constants>
</class>
